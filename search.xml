<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快手暑期实习一面整理</title>
      <link href="/posts/kuaishou_shuqi.html"/>
      <url>/posts/kuaishou_shuqi.html</url>
      
        <content type="html"><![CDATA[<h1>总体整理</h1><p>先总体回顾一下面试，其实发现面试官更希望的是能够提纲挈领的回答很多问题，而不是回答过于细节化的部分，有些太细节的内容反而会让你表现的很凌乱。诸如问你设计I/O多路复用的目是什么，其实是为了解决效率问题。</p><h1>框架部分</h1><h2 id="说一说Spring和Spring-boot的区别">说一说Spring和Spring boot的区别</h2><p>其实Spring和Springboot的区别还是蛮多的，接下来我们就简单聊一聊这些部分</p><h3 id="相同点">相同点</h3><p>其实SpringBoot是基于Spring实现的一个更为轻便的脚手架，他们的核心模块同样是：</p><ol><li>IoC，控制反转。控制反转的目的是为了解耦合，是将依赖关系的管理从应用程序转移到一个容器或者框架来实现松耦合。简单来说，传统的编程是直接创建他们所依赖的对象，而在IoC中，这种依赖关系的创建和绑定被外部化了，也就是由IoC容器负责。</li><li>DI，依赖注入。允许对象定义他的依赖，但是并不直接创建们，而是由IoC容器提供并注入其中。常见的注入方式包括：构造函数注入、方法注入、字段注入。</li><li>提供了AOP，也就是面向切面编程。支持灵活定义切点和环绕。</li></ol><h3 id="区别">区别</h3><p>区别也是很明显的</p><ol><li><p>Springboot首先是遵循了约定优于配置的原则，很多时候开发者所做的选择是一致的，所以不需要开发者手动配置每一个细节，比如Bean的扫描路径等等，当遵循这些约定时，框架或工具可以自动完成许多常见的任务和设置，从而减少了配置的工作量。</p><p>基于约定优于配置的原则，springboot进行了很多自动配置。当你在springboot里引用了一个起步依赖，springboot就会对这个依赖进行自动配置。</p><p>举个例子：</p><p>如果你在项目中添加了<code>spring-boot-starter-web</code>依赖，Spring Boot将自动配置：</p><ul><li>嵌入式Servlet容器（如Tomcat、Jetty或Undertow）</li><li>Spring MVC DispatcherServlet</li><li>转换器（Converter）、格式化器（Formatter）</li><li>静态资源处理</li><li>错误页面映射</li></ul><p>添加<code>spring-boot-starter-security</code>依赖后，Spring Boot会自动配置基本的安全设置，比如：</p><ul><li>HTTP Basic认证</li><li>CSRF保护</li><li>Session管理</li></ul></li><li><p>Springboot的内嵌服务器</p><p>Springboot默认支持内嵌Tomcat、Jetty等服务器，使得部署更加简便。</p></li><li><p>不同于Springboot可以用starter扩展，Spring提出了spi的机制，允许第三方开发者为Spring框架提供自定义实现，使得Spring的扩展变得更加简洁。只需要自己定义完成一个AutoConfiguration加入到AutoConfiguration.imports文件中去就可以自动加载了。</p></li></ol><h3 id="了解SpringMVC吗">了解SpringMVC吗</h3><p>SpringMVC是是Spring框架的一个模块，专门用于构建Java Web应用，遵循Model-View-Controller设计模式。提供了丰富的功能来处理HTTP请求和渲染视图以及管理应用程序状态。</p><p>分为几个重要的模块和过程：</p><p><strong>DispatcherServlet</strong>：SpringMVC的前端控制器，负责接收所有的HTTP请求，并且使用HandlerMapping找到他们对应的处理器，也就是Controller方法，如果找到了对应的Controller方法，通过HandlerAdapter调用该方法</p><p>Controller处理完成之后，会返回一个ModelAndView对象，其中包括模型数据和视图，这时候就需要进行视图解析与渲染</p><p><strong>视图解析与渲染</strong>：<code>DispatcherServlet</code> 使用 <code>ViewResolver</code> 将视图名称解析为实际的视图对象，并将模型数据传递给视图进行渲染。</p><p><strong>响应生成</strong>：最终生成的 HTML 或其他格式的内容作为 HTTP 响应返回给客户端。</p><h3 id="之前我们聊到了IoC，顺便聊一聊bean的生命周期呗">之前我们聊到了IoC，顺便聊一聊bean的生命周期呗</h3><h4 id="先简单聊一下一个对象的生命周期吧">先简单聊一下一个对象的生命周期吧</h4><p>太经典了这个问题，这个图永世流传</p><p><img src="/picture/object_lifecycle.png" alt="对象的生命周期"></p><p>必然会问的啦，类加载阶段，主要是做了三件事情：类加载器加载（双亲委派模型），将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口</p><p>然后验证、准备（给static的基本数据类型赋值为默认初始值，对引用类型赋值为null）、解析（解析阶段就是虚拟机将常量池中的符号引用转化为直接引用的过程）、初始化（根据Java显示赋值的内容进行赋值初始化）、使用。</p><p>最终的卸载分为两类，一个是对象的卸载，一个是类的卸载。</p><p>当一个对象不再被引用，即不可达时，该对象就会被JVM垃圾回收器所回收掉，从而结束对象的生命周期，此时类在方法区内的数据并不一定会被卸载。</p><p>而类的卸载是很难的，一般来说使用Java自带的三种类加载器（启动类加载器，加载Java的核心部分；扩展类加载器，应用程序类加载器，加载环境中的Jar类）加载的类在虚拟机的生命周期中都不会被卸载。</p><p>类的卸载只有三种情况才会触发：</p><ol><li>它的加载器被回收</li><li>该类所有的实例都已经被回收</li><li>该类的Class对象没有被任何对象引用</li></ol><p><strong>所以类的生命周期为：类加载、验证、准备、解析、初始化、使用、卸载</strong></p><h4 id="说完了一个类的生命周期，接下来我们简单聊一聊Bean的生命周期呗">说完了一个类的生命周期，接下来我们简单聊一聊Bean的生命周期呗</h4><p>Bean的生命周期主要包括：</p><ol><li><p>IoC容器根据配置文件，实例化一个Bean</p></li><li><p>对Bean进行依赖注入</p></li><li><p>对Bean进行一些Aware的初始化，比如如果bean实现了BeanNameAware接口，就给他set一下name，BeanClassLoaderAware、BeanFactoryAware同理</p></li><li><p>调用BeanPostproccessor的before方法</p></li><li><p>初始化Bean，也就是调用Bean的init方法</p></li><li><p>调用BeanPostproccessor的after方法</p></li><li><p>使用bean</p></li><li><p>销毁bean</p></li></ol><p>值得一提的是，Spring IoC自己能管理Bean，自己可以调用Bean的destory方法，不通过Java的GC回收bean</p><p>一般是在Spring上下文关闭之前调用所有Bean的销毁方法</p><h1>中间件部分</h1><h2 id="聊一聊Redis的特点，以及为什么要用Redis">聊一聊Redis的特点，以及为什么要用Redis</h2><ol><li>基于内存实现，数据存储在内存中，因此读写速度非常快。</li><li>单线程，但是使用I/O多路复用。</li><li>高可用和扩展性，支持主从复制</li><li>支持发布订阅模式，允许客户端订阅特定的频道并接收该频道上的消息。这使得 Redis 可以作为消息队列系统使用。</li></ol><p>使用Redis可以有多个方面，包括作为缓存、保存过期时间维持心跳等。</p><h2 id="既然提到了I-O多路复用，那就简单聊一聊I-O模式吧">既然提到了I/O多路复用，那就简单聊一聊I/O模式吧</h2><p>我看了B站一堆教程，很少有能把IO多路复用讲明白的，所以我试一试看看能不能讲明白吧。</p><p>其实从这里开始写的时候我也没学明白IO多路复用，但是私以为我是理解BIO和NIO的，所以就从这个部分开始写这个Blog。</p><h3 id="BIO">BIO</h3><p>BIO的概念是同步阻塞IO，两个关键词，同步，阻塞。</p><p>同步在这里主要是看有消息返回之后，是否需要原线程继续处理。</p><p>阻塞是指一个线程在等待某个操作完成时暂停其执行的状态。</p><p>我们以Socket通信的方式来实现这些BIO，以一方请求另一方为例子。</p><p>我们先设计一个Socket的服务端，客户端每次发来消息就让线程休息5s，来模拟执行耗时，5s后给客户端发送一条消息。</p><p>当前我们设计一个客户端，一共进行四次输入，第一次客户端输入不阻塞等带服务器的返回。</p><p>服务端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//定义服务器的接收端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server started on port &quot;</span>+<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();<span class="comment">//阻塞等待客户端连接</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BioHandler</span>(socket)).start(); <span class="comment">// 为每个客户端连接启动新线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BioHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BioHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="built_in">this</span>.socket.getInputStream()));</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="built_in">this</span>.socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                String inputLine;</span><br><span class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 阻塞等待输入</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Received: &quot;</span> + inputLine);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                    <span class="comment">//sleep5s，模拟处理时间</span></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Echo: &quot;</span> + inputLine); <span class="comment">// 回显消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端不阻塞等待返回如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//假设我们固定服务器的端口号为8080，之后我们会访问这个端口号，然后我们会模拟服务器需要很久才会返回</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">//定义发送流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//定义接受流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Connected to server. Type messages and press enter.&quot;</span>);</span><br><span class="line">        String userInput;</span><br><span class="line">        <span class="comment">//我一共进行四次输入，按理来说我这四次输入间隔时间应该是很短的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            userInput = <span class="string">&quot;mess&quot;</span>+i;</span><br><span class="line">            out.println(userInput); <span class="comment">// 发送到服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span>+userInput+<span class="string">&quot;\&quot;已经成功发送，当前时间是&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//描述成功发送到服务器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们看客户端和服务器端分别的时间</p><p>客户端</p><p><img src="/picture/bio_c_nBlock.png" alt="BIO非阻塞客户端"></p><p>服务端</p><p><img src="/picture/bio_s_nBlock.png" alt="BIO非阻塞服务端"></p><p>可以看出，非阻塞的客户端是能直接把全部的消息发给服务器端的，只不过服务器端是一个一个处理的</p><p>那如果我们的客户端阻塞等待服务器端的返回呢？</p><p>只需要在客户端里加上一行代码就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//假设我们固定服务器的端口号为8080，之后我们会访问这个端口号，然后我们会模拟服务器需要很久才会返回</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">//定义发送流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//定义接受流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Connected to server. Type messages and press enter.&quot;</span>);</span><br><span class="line">        String userInput;</span><br><span class="line">        <span class="comment">//我一共进行四次输入，按理来说我这四次输入间隔时间应该是很短的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            userInput = <span class="string">&quot;mess&quot;</span>+i;</span><br><span class="line">            out.println(userInput); <span class="comment">// 发送到服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span>+userInput+<span class="string">&quot;\&quot;已经成功发送，当前时间是&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//描述成功发送到服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;echo: &quot;</span> + in.readLine()); <span class="comment">// 阻塞等待服务器返回消息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这时候客户端的发送的方式是什么呢？</p><p><img src="/picture/bio_c_Block.png" alt="BIO阻塞客户端"></p><p>从结果我们发现，客户端阻塞在这里，等待服务器消费完一条消息才能执行自己接下来要做的事情，如果这时候客户端不是要给服务器发送消息，而是做其他的事情，是不是这些等待时间就是不必要的，完全可以去做其他的事情。</p><p>那么这时候，我们是不是能有这样一种方法，我们不在这里等着服务器处理完，我可以先去做其他的事情，然后时不时看服务器有没有处理完，处理完了我再获取这个数据呢。这时候NIO就应运而生了。</p><h3 id="NIO">NIO</h3><p>NIO的概念是同步非阻塞IO，也就是说我不用阻塞在这里等待对方执行完毕。而是我传递完消息之后就去做我自己的事情，时不时的通过Selector来看一看它是不是有返回值，也就是ReadAble状态。</p><p>所以接下来我们就通过Java来简单实现一下客户端和服务端。</p><p>首先介绍一下Selector，它提供了一种机制来管理多个通道（Channel）的I/O操作。通过使用selector，可以利用一个线程来监视多个通道上的事件（如连接请求、数据到达等），从而实现高效的服务端应用设计，尤其是在处理大量并发连接时。</p><p>我们先来改造客户端吧，改造比较容易，首先是消息就不通过PrintWriter发送了，因为他们属于不同的I/O模型，我们这次就得使用ByteBuffer来存我们的输入数据，然后让Channel去write。</p><p>同时呢，我们需要把Channel注册到Selector上去，让Selector来为我们轮训Channel的状态，当然也未必是轮训，后面我们讲到I/O多路复用的时候会说到。虽然这部分的代码内容稍多一些，但是我的注释写的还是比较翔实的。</p><p>比较有趣的是，这个客户端的实现没有考虑到粘包问题，刚好让我碰到了我以前比较好奇为什么会出现的粘包问题，这部分我们会逐渐优化给大家看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentLinkedQueue&lt;String&gt; messageQueue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        clientChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//将Channel注册到selector中去，并且设置该通道关注可连接事件</span></span><br><span class="line">        clientChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="comment">//当channel没被关的时候一直循环</span></span><br><span class="line">        <span class="keyword">while</span> (clientChannel.isOpen()) &#123;</span><br><span class="line">            <span class="comment">//这段代码还是会阻塞当前线程，直到有注册到selector的通道准备好了进行某项操作</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//一旦 select() 方法返回，通过调用 selectedKeys() 方法来获取一个包含所有已准备好进行操作的通道的 SelectionKey 集合。</span></span><br><span class="line">            <span class="comment">// 每个 SelectionKey 都代表了一个与特定通道和操作相关的键。</span></span><br><span class="line">            <span class="comment">// 这些键包含了关于哪些通道准备好进行哪种类型的操作的信息（例如可读、可写等）。</span></span><br><span class="line">            <span class="comment">// 其实这里包含了多路复用的实现，因为获得了准备好的所有channel的信息，而不是一个channel准备好了就切换回用户态</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">            <span class="comment">//然后对所有准备好的通道依次处理</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="comment">//在第一次channel可用时候，其实只会触发这个isConnectable()，因为我们只注册该通道为可连接的</span></span><br><span class="line">                <span class="comment">//这时候就会调用我们定义好的连接handler</span></span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    handleConnect(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在之后我们关注了可写事件，如果这个通道可写了，selector返回的key里就会设置为可写的</span></span><br><span class="line">                <span class="comment">//这时候就会调用我们定义好的writeHandler</span></span><br><span class="line">                <span class="comment">//可写其实是频繁触发的</span></span><br><span class="line">                <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    handleWrite(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这时候如果服务器返回消息了，就会触发可读事件，selector返回的key里就会设置为可读的</span></span><br><span class="line">                <span class="comment">//这时候就调用我们定义好的readHandler</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    handleRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clientChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key selector的包含channel信息以及其对应类型的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleConnect</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//从key里获取channel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//如果连接完毕，就要把channel的关注切换为关注可写事件</span></span><br><span class="line">        <span class="keyword">if</span> (channel.finishConnect()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接建立成功，开始发送数据...&quot;</span>);</span><br><span class="line">            key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">            <span class="comment">//当然其实也可以这么切换，就是既关注可写事件，又关注可读事件，毕竟谁规定服务器不可以在连接上之后给客户端发消息的</span></span><br><span class="line">            <span class="comment">//key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span></span><br><span class="line">            <span class="comment">//连接成功之后我们往消息队列里加点数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                messageQueue.add(<span class="string">&quot;mess&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//触发可写事件的时候，我们从消息队列里挑选一条消息发过去</span></span><br><span class="line">        <span class="comment">//所以我们可能会触发粘包事件</span></span><br><span class="line">        <span class="keyword">if</span> (!messageQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;触发可写事件且有消息要发！&quot;</span>);</span><br><span class="line">            <span class="comment">//分配写入字节流</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">//从消息队列获取消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> messageQueue.peek();</span><br><span class="line">            <span class="comment">//重置缓冲区，将限制设置为50，并将位置重置为0</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(msg.getBytes());</span><br><span class="line">            <span class="comment">//将缓冲区从写模式切换到读模式。</span></span><br><span class="line">            <span class="comment">//它通过设置限制（limit）为当前位置，并将位置（position）重置为0。</span></span><br><span class="line">            <span class="comment">//这意味着接下来可以从位置0开始读取数据，直到达到之前的位置（现在变成了限制）。</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//向channel写入数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesWritten</span> <span class="operator">=</span> channel.write(buffer);</span><br><span class="line">            <span class="comment">//如果写入数据长度为0，就不进行接下来的操作了，也就是从消息队列里删除，那时候就会重新发送消息</span></span><br><span class="line">            <span class="keyword">if</span> (bytesWritten == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果全部写入成功，就会把消息删除，并且打印已发送</span></span><br><span class="line">            <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sentMsg</span> <span class="operator">=</span> messageQueue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span> + sentMsg + <span class="string">&quot;\&quot;已发送，时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换关注读事件，但保持写事件关注</span></span><br><span class="line">        key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((bytesRead = channel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//同样是把buffer设置为读状态</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//读取响应消息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;收到响应：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, bytesRead)+<span class="string">&quot; ,当前时间是:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了验证读消息之后还能触发写事件，我们每次读完往messageQueue里加2条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count; i &lt; count+<span class="number">2</span>; i++) &#123;</span><br><span class="line">            messageQueue.add(<span class="string">&quot;mess&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        count+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，设计完客户端之后，就是设计服务端了，与之前BIO处理多个连接的方式不同，我们服务端这次不使用多线程来管理多个连接，而是直接使用Selector来管理多个Channel，ServerSocketChannel和SocketChannel一视同仁，都交给一个Selector管理。</p><p>让我们端上来吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// NIO基于Channel控制，所以有Selector管理所有的Channel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 设置监听端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 设置Selector管理所有Channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 注册并设置连接时处理</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功，监听端口为：&quot;</span> + <span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// NIO使用轮询，当有请求连接时，则启动一个线程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">keySelect</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (serverSocketChannel.isOpen()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (next.isAcceptable()) &#123;    <span class="comment">//  如果是连接的</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="keyword">if</span> (accept != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//把新的会话测channel注册到selector里去，让Selector来管理它</span></span><br><span class="line">                        accept.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//并且把它的感兴趣状态变为可读状态</span></span><br><span class="line">                        accept.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//一旦可读了，就代表客户端发来了消息，那我们就去处理这个消息</span></span><br><span class="line">                <span class="keyword">if</span>(next.isReadable())&#123;</span><br><span class="line">                    handleRead(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实处理这个消息我们依然有一处是阻塞的，就是我们返回给客户端的时候，要求客户端是写可用的。</span></span><br><span class="line">    <span class="comment">//但是写可用的触发是很多次的，一般都是写可用的，所以我们就没有做过多的干预</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, read).trim();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端收到消息：&quot;</span>+msg);</span><br><span class="line">        <span class="type">String</span> <span class="variable">outMsg</span> <span class="operator">=</span> <span class="string">&quot;【Echo】&quot;</span> + msg; <span class="comment">// 生成回应信息</span></span><br><span class="line">        <span class="comment">//模拟消息处理时长</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.put(outMsg.getBytes());  <span class="comment">//回传信息放入缓冲区</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);<span class="comment">// 回传信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器的实现我们写的时候还是阻塞的，但是其实写可用触发频率是很高的，所以我们就不把这个阻塞考虑进去了。</p><p>这时候我们起一个服务端，一个客户端看看情况如何！</p><p><img src="/picture/nio_single.png" alt="NIO单客户端"></p><p>是不是出现了粘包问题！在服务器处理mess0（也就是sleep 5s的时候），后面的mess1、mess2、mess3、mess4都到了，但是我们没有使用头部或者区分符号来进行区分，导致出现了粘包问题。</p><p>但是恰恰是这个粘包，也进一步佐证了我们实现了NIO，因为粘包是NIO的常见问题之一。</p><p>那是否我们的服务器在不使用多线程的情况下，不阻塞的同时响应两个客户端呢，我们来试一下就行哩！</p><p><img src="/picture/nio_two.png" alt="NIO多客户端"></p><p>由此可见，是可以的！只不过单线程响应就要做好逐个处理的缓慢准备。</p><p>在这里已经讲的够多了，接下来的粘包和I/O多路复用请移步我的另一篇Blog，当然那篇Blog也会重复上面一部分内容！</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BGP整理</title>
      <link href="/posts/bgp_introduce.html"/>
      <url>/posts/bgp_introduce.html</url>
      
        <content type="html"><![CDATA[<h1>BGP整理</h1><p>主还是整理一下BGP相关的内容，毕竟有一段在BGP的实习，防止自己逐渐忘记。</p><h2 id="简单介绍">简单介绍</h2><p>BGP也是路由协议之一，主要用在AS间交换路由信息（eBGP），当然也可以用在AS内交换路由信息（iBGP）。</p><p>与其他路由协议利于ISIS、OSPF等建立在IP协议上，RIP建立在UDP上不同，BGP建立在<strong>TCP</strong>连接之上，默认端口号是<strong>179号端口</strong>，所以我们这里有个观念，就是BGP其实是一个应用层的协议，即使它是一个路由协议。</p><p>BGP既然建立在TCP连接之上，就要求BGP对等体之间有稳定的路由链路连接，并不要求对等体之间直接连接。所以BGP所在AS内需要通过ISIS、OSPF、RIP等建立起连接，而通过BGP和其他自治系统通信。</p><p>BGP是基于路径向量的，这既不同于距离向量，也不同于链路状态。BGP所要传递的信息不仅包含到达目的地的最佳路径，还会携带所经过的全部自治系统的AS号，避免路由环路。</p><p>同时，BGP设定了很多属性和策略，可以根据他们来决策不同的最佳路径，包括：本地优先级、多出口区分符(MED)，权重等等。</p><h3 id="常见问题">常见问题</h3><ol><li><p>为什么其他路由不适合做域间路由？</p><p>a. 路由规模问题，IGP主要关注较小的网络环境，没有为处理大量路由信息而优化</p><p>b. 策略控制方面，常见的IGP协议没有提供BGP所提供的诸多策略控制属性，不能对流量进行细粒度控制</p><p>c. 防环方面，一些常用的IGP防环策略（1.最大跳数限制，2.水平分割（接口a收到的路由不会再从接口a广播出去），3.毒性逆转（路由失效的时候并不是直接删除，而是告知邻居自己与其距离无穷大））在跨AS其实并不能很好的使用</p></li><li><p>聊到了IGP的防环策略，那就聊一下BGP的防环策略吧</p><p>a. AS路径过滤，就是当收到的路由更新中包含自己的AS号，就忽略这条路由</p><p>b. IBGP水平分割，iBGP不会把自己从其他iBGP邻居学到的路由转发给另一个iBGP邻居，但是可以转发给他的eBGP邻居</p><p>c. 路由反射器，路由反射器允许一些路由器作为反射器，可以将从一个iBGP邻居学到的路由反射给其他iBGP邻居，解决了需要全连接iBGP才能防环的问题。路由反射器RR会接受与其建立iBGP连接(客户端)以及其他IGP连接(非客户端)的路由器的消息，从从客户端学到的路由反射给客户端和非客户端，从非客户端学到的路由仅反射给客户端。</p><p>路由反射器会在路由更新中添加Originator_ID，记录原始路由器ID，当再次收到相同Originator_ID的路由更新的时候忽略。</p><p>同时如果存在多个路由反射器，每个路由反射器会在Cluster_List里添加自己的Cluster_ID，如果发现自己的ID，就证明集群内循环，直接丢弃</p><p>d. BGP联邦。也就是在AS内划分多个BGP联邦，每个联邦自治，可以使用联邦AS号来避免环路</p></li><li><p>BGP和ISIS的区别</p><p>a. 一个是EGP，一个是IGP</p><p>b. 运行层次，一个运行在TCP的179端口上，一个运行在IP协议之上</p><p>c. 采用的路由算法不同，一个是使用路径向量算法，一个是使用链路状态算法</p><p>d. 适用规模不同，BGP适用于大规模组网，ISIS适合中大企业内部组网</p><p>e. 策略控制力度不同，BGP支持更加细粒度的策略控制</p></li><li><p>BGP和其他协议怎么互相学习</p><p>BGP有IGP路由引入</p></li></ol><h2 id="BGP的属性">BGP的属性</h2><ol><li><p>Origin，路由来源，是通过什么协议学到的，比如IGP，EGP，还是重分布</p></li><li><p>AS_PATH，途经的全部AS号，主要用于防环和根据路径长度选路</p></li><li><p>Next_Hop，下一跳，iBGP一般不会修改下一跳，eBGP会把下一跳修改为本地路由器的接口地址</p></li><li><p>MED，多出口鉴别器，主要是影响其他自治系统如何选择进入本自治系统的路径，较低值优先。仅在两个相邻的AS之内生效。</p></li><li><p>Local_Pref，本地优先级，主要是用于选择怎么离开该自治系统，同样是较低值优先。</p></li><li><p>Community，主要用于路由分组</p></li><li><p>Weight，某些BGP实现商的特有属性，主要用于最佳路径选择</p></li></ol><h3 id="常见问题-2">常见问题</h3><ol><li><p>说到BGP，了解运营商的单线或多线处理吗</p><p>主要是一个网络的ISP接入情况，单线指的是一个网络只使用一条线路或一个ISP截图，简单直接，但是会出现单点故障问题。</p><p>多线处理也被称为BGP多宿主，指的是通过多个ISP接入互联网哪过，通过BGP来管理优化这些连接。</p><p>多个ISP每个需要有独立的AS号，每个ISP之间需要建立eBGP对等体关系，配置出口策略和入口策略等。</p></li></ol><h2 id="BGP邻居建立过程">BGP邻居建立过程</h2><p>输入peer ip as_num as_num指令后一般会接受这些</p><ol><li>建立TCP连接，首先要在两个路由器的179端口号上建立TCP连接，建立成功之后可以初始化BGP对话</li><li>交换Open消息，主要包括双方的AS号，保持时间，BGP标识符（通常是IP地址）</li><li>参数协商，主要是判断Open消息的参数是否正确，正确就进入Established状态</li><li>Established状态要定期发送Keepalive消息来保活</li><li>然后就可以发送Update消息了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目介绍 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目介绍</title>
      <link href="/posts/project_introduce.html"/>
      <url>/posts/project_introduce.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e0eddff50479bfc04ea4a68fe6a2a731f852ab7ef6024f2927f15e8b8d0c4a83">a8b0df52fc69ea18510492bd532eeda5abb824d8f1dad69a9a35d594ef5c4e745d9dfdeaa73551f6db9ec853f35496c3b91c04a488b6657b21c8dc72a32ec96d74c3597ef5dfa94d1eb595b647c63215ff89eeb3a20abc0553c7eb8805152bbb2f2bde7c9a9519c5b61bbd3a392744febe0a6719a07c940ace87153553bc5f85aeff9c5736548c35298c652fce6de06ae1efbcac91df71995a480647091a4b6df3bb7c5fe2b10a12bac197f2fa7747fdddcc983fe9e3f1148dbaf427b931ac22b404b93a6ec2d860a710c1fa6ff0ebff6ece32102871bca675292c450e51594548f65e2a4b37cd88b9688202715063027871973bd42dda1f69363105396e742d3dc3b8c434f626bbb4ab076feb2eb9422d432a27080ba1f72fa1d2d04bbe810b70a8b4242679ed0825ab0b24a3db043327ef52255cce1a4c76ee499487dc8bd3fa0312e02bbb951722581d5d379bb62f1fa3bc0cd7d50eef09fe833e0ea61f60f3f9d49631d4c49dc486a573ecb1cd845dae4d6fb1412651c42a2bc887dfc5057500076fad789542353677196552479aebef04c3ec8ca3e6822d441db510fd4067435518889d2de435d705b2823ae15c363972f1a8816ea3273a12ebd47b03b64b26fd763cc68fad583309369ad36bc67e5c487b37bcc61253e4012ec3587623f1c718e802c2eae1d72f2925b09fb0a5229e056ba99cb4670fbc2d174e8cd6e88d74c0649c4399293dffc010116548bb3d21393beec59471d8d8189bf558266f724fefe1593b164f37788b149767429090ca37f04b571a2896d40e465af7a127868913fa329510f548159bec16ef59ccea0ec1db92066f7a7a65a7290b51767776690ead2769cf30df906980a963327b1b675d410baf364f3cb55c63a2b41cd69e9977e0ff840a8fe7ffb143023814c911f92150bce851c102b24db61a9480290026fda259ce4991b882f20ec2ba05bad09f95cfb6a9b2df90e089e1ed1e41268d5b241524dce53c3ad182404f0f3f2d42c87ec78286627dc37bb4901630a1c25937963edcf4b2ef1b1e235d24ac24337798997626cf662a71aba9886a447ad4614b845e606b468b8df935e2c4b9e35bc5210e82dae1a55dc683ecab2545cb2e93fbd381f1f4965dcf9986f234ac1952b365f5fba28ab9e480c63e8756076642f77bf9533ed770b021cb727851a38b4bfcd485ee8f3d707b40cd82948b1fb6c872ca7ef65895a45a1fe5a59f4ab0f0593e821eaf0ab0ea56a20904e7133ebd808c208ba54fa3a31f3352e14a00adbb83530a559f1bae7524c364c624d08cf4e1d1dabc5e1656f96aabaf88605071eb3f7f24e41cc886f7f7a58762743075159466b4e7324bb27cf971729bf01ae415bfd9bae719102279a93c514780fd5c0ec5b9d1e982f905b938de38abec9a9946ff1acd56e779a9c3fffc1aed993f48cf6f4024ac58b236d9609015bd18f576d5ce4bf16480dce673b47db39dca7416db9be3a879c3849fe9edb01eb238a8f42a007c6508c280b10b95b70a62829035bf86e801908d9080caae8c8e2a10215bc7ae93dc4179b06547478c3621cf6792d930f12af1a9c0bc36ff47d744be2d5027442b17e2b11e5dafb2b2bfd0a622bb28eaa9570894d83b4c2c5155815bcc0e00ba3eb699ec0fb2f841799c581a3b04ba3d0f354202dc4c930b9dd4b3ab7787433e40fd04f038ef6382adac7ac070e18886131e3c8b1853cf808c2298dd923b79202ff20c9f392c115176774d7b181748e6ab3cdfe63ac23d0afe0db421136130d9d0259fac06c274ab77235960b247b9509bcceec96f520e614ab5c1a1c4f46e44e45c31074611f670ac613f3dc291cfdfc50a1317e1681f5f5fd00b431ec6a2e48fb05441873de872a27f3b03ae9ed6f42c381e8b8434bbf275cc6729761f20a5f5b6a903690b03fe24589d8b9023716ffb37a76e68645698a898a05dcd519969048fe9b041fa8e9df94990c4c8cba0cd2237bbb9ba12dc8ef4f929762a0ce6d9f004dce7c4e55f02d8337ecbe13ea28160ac910c64728931f33a3d5df6fa4ee14ad5d164d16c22f258a7704491ab7f2422b9e7d432212f57f37c7afa1a691215da09d16a0cb506ee7dbd09bdec3f71d58d29da485a09af9f84e4479fa0f332accbc0e0d154506dbd0e52c2007feb3374ee7e686c7bb9de69da7fbc8d04e883f561475deee87415f9f3e84508f03a454948f9466b774ccc8e4d59c14b903cfa561994aeb8891754ebd5bf8d43f50c537df49e639a393cc423235d6fe2429c6bb5680d150f743e68f3715a8dbab935c7ff97b51f1485a35bfb481265622b88c056f2431f5e7a5947411ffff4bfa4626729f2c83ae1d3206d219f7c3bf878c5a84faddfc5e3bdf1394b98980c5f9cfbc7f9f41cf671f1e07714e0dcc9d4f9fa03810e726d3e5cc10d381069517fd303e9f1c162755ddad5d4f307daca03fcc7744fffe338a8126469c3f03c82c3fc3a6c706359809c9021f8b166d0687d5bafbeb5af175be47862a89af705c24250c29a486fc5b038ba16a87c8c7ec2e88e07bb6753734db27ec5d4a179e83e2990c4e85e033b434c3e65da7ea8434f048607d57719ec795729d44771581b1dafef585827b54e030489fc5a8bc3aaa48c0cd814f14fce3eccc94f47f08fe6ba170800dbad2b3ebf3405fe3ada98880b59a7c82efe831f1b4e673e3238759ab3bfe272944cb7e3ebc083ced2ed6b49cddccb786f2dc180cdf0dcb7177e78bff66bd2e28110221051dbf5abd84d7413f7c17005ebd4bc88ccded4a35ea0d469f06316b9c8ef228e84aab94d94c0538be6e7ad3ea1e9626da975c7d5aae7fb5dfb88cd613e3bfbe32a0bc60e9cc1f634550ec044a906470099271a361c08569ded0dbdc29e591d1394a3e42a313d96f46d23936d333ee9943d439a69437c57f109cb763163abe50a12168f7dbd0a3c0978bcf87c88d8ca637e71fd7559f86e57f1c561afb4f86804f696c39b055d88567c38d4ae9505b07cf39823b100de1d70f2bb2a76958d70251d9dabe288b8cdd442ac2488b17d1a6c61be2a98492f65ab955ae296933db23a87c137d45e77c1358324d11c53bcf4290a47238bf9c9d76c51b394615d038cff99fc6e225b8d5f81e7aece480f46098eb05bac34a665784b0822c3e49c6c4789cf811d3933ec796906523a8d09f873a428d7e05e9b2db4fc226ad880d060081960a8bf289a52c3590cc1a8e7678b0bcd007f4ab394a40be626fe89e1c7016150ccc4f351f35f0a0c7b5aaf5715d709e50fa4af1f7f56ad4b4601b9a6adc29227572a545711c3704e5433b795877ba874596ab27198ca7d2efd8895d79534c3cf5bffddf3a6933c1d2356a2cbea0ccb81cf71137aa44dc3ac93aa1446fab06f83274d0838feceb646e3f9e50bf03fe451f323e88040851082c1befde0d45b3ac8ff977284af897c4ecf21437c453970610b72d87de689e21298fb136511e2df8a175c00b7bbef1c8582c71f264f6d295814d62044baf772241d111bfc161ecf8f8523b5b560110441a47446b409ad0241d07182de145b1190b8fe6b2a2dc12a38f90d1131372811552b4700d3c263bcde738375f940f4d5937dd2b6054710ae90a8501c01d653526b39062d2e967b45371f29e07b86d593d0260ccee7ff1fc1bb9b8770db029c70580a42a3f4ec0b4804dbe8f193993ed893883b6ed53a78692a0ca2dcc31602bd6dee9c826fab9859b1e118dd0f476ebbdcd3950557d70a82ab52e3541bb36c7363618ae631ddc1533540903224f904ede5c703f241301fd65a61fa8f7cc4e271e08952c68229fbe4237c0d951f66c9d6a5277f85c88c8035b273838d4424e4913fc64ad0cb46b3a3d11ef1846f6c1d71c62100f9a84aaf9ecdd3771b3066e1f492ebaf2a091c3b39eae12b1092099da5ad10be7740cdeb77ef1eb6265bea755659745e3a3b1e3dfb9fd6e51e51c2300cb7ccb13ce1f829c2d6d45fc5fb8b857a8b850e5972b238761e6d03dac6472266ba163f3c58ded59a499e7d9356dd5f2c02c4ae2f0ed415827db0455c3f06d283cb4032800357825e2c6d758d621dfb225a45901803ff8f0118897a46f98afbe0b887ffae834a0702d2d673f41fdbbff6e4f0aef0925cb15ad45882afd181d7f67a420b388f87caf9141ca4726f7dd091ba1629cae8847f80ba871644a1afad6a474f44fa2e7aea22f9a8c83bf7fa6f18f1fc0b9b3b1c674e01ac056e3b778c8ef567661a42138f8ed89b49d9c2b4efe9ebae6125c5d651faf07285753a7b8ef80c5a15b5994dab93fa58c4daac0934afe6f932d857c3f7e244c1da818cf8f2431768ab910b9b717f66ab9e69baed83848f9d4edaf83874202c27999444877ab75ff98950ae10b89992acb9ee7c88a2a615086cc4f924cb695992d92e8762e55f53522203058f745ad9a50fdb9b2efe538babc5892bb43756960f4db165c92c9a0964be92c1ef2d3c24165526c147fb5736e79dbdd714001ee7d8f3cb43a11a07a0aa128ac895eb150b2182f86f81282c170099a104c47935f06978bc40d8cb575e0098e9280c411f47faded7a5b15b8b1248496e28b04d3847b32b60556047b3ec041b5e14b752f4ffcbb6798061cca6b95b56dc0204b8b52a30ca4cb810f398fbacbd3eb2ed078052e3b1f0edac043412d90ef27a8c1d3db180454453fb9beb428ac050e1cf066d16bde7f439506523085e5578a07a5e7f113e18d11ed62f07b99cbb45b8492351c5a03801a9bd9a4f8c396bbd1b168448f7f16383cc2653d147c1e5883db31855257798bb9d42e7da065281766de0e35b249fa63a66987e7b194d7fa937253414e68b5136f48e0341f23facf6f7f68b298e825265f03f0035b3150530d676bb0236a461e77c99a8dfd3b733adf271a448d7e976b9dba021c14044cfbf492c0c338b5a9e1940b9acb3ce249412874664e6d023454eb5581602bbd2c1ef738442b52d37e5171cc7d01e1e7042ecab46591f47160990b97d8d8505c88017c07b12de03aa4756a02f719ee7d7f4b045b015c6eb50da85b458f1204e04eed8deaa7769d469b0828faf606ff6bcc2482512f5ac6606905e24708b5784a13c2a3959940274062d18920f9c2d2c92bad26abb350501eb704d912e2f19974130ac8e3dab1115c31710345fcfe6b593f4d7a03011cd79a4cf61a35e090f7769b8ce29aed6c4ff868ee70b52481e5a9ccd8d57fc5d92b973fedcc9bee099079c7b77e19198b2d40e2271c56fc97bd2577e9c1fc87e7b9f66feb13e412af08045b6f8fed2745140214fe6eade14bbb8614607d160f5f46c80e5419e3c7ee3a684e42943ca6f1b15f032d917e34cabdd53f7c97fab5429ae7dfda07874ed24519c4a58f6ba417f0b4048245c4fdacfab54465611c27c37f82e7487d69c09840bb7641802efa257f0bebc3d7dff5b12c4bda6000ba5418c2fcf2620d1b9dd89208a693d40f8156a645d490af482777258a8ed2ba00761b08d6f0ee05c6066fa13761b6f8881fcc89fad3b8da489a4b15285ead5d46a08e7d8f0dc5cebed523d0a51339362b1c68cc611b742275e5bf51575c1253e6ee74119c253d7f57d90eca3e25561ee922438ab635db72de1644da670f6a35e0189e56b6bdabaf32f8faa22b73c33352c60710b02f50e679bb9f18af391c78526f9ff0e5e06eafcf53e3297caaa32e69dc60cd09d2db1282ea4c17b5b1d832f8af1f673ea51fba608cbc6b5f8ef9f710d39d1e849acbc2e4e28cba4b38503931c669a69c504c9807bbd48881c110c08c5aad1f55ad2c5cf78d263320a7d9f7bcb3e015be26ec1c27b510a9c5c6b197ec465f0ba97dcb204638cf02a49fb12e9a536605053a57a5f01693cb13caaeb4ea561d963043248b82bc193f599d7d821c01f7a5d2c3f69aac71ba27d0d3befa0dc3940e9aa33b93688bbb8c87b883a5a355418b1352e1d824f96e8365d7f9eccc29a541b8627b222dac13a955e162df5dcfdeea8e17f755ce70b1e81e4aa82425ccd1a3f34d4a7385fad13ab8cd8dd648138f10fdbed7d8e5587d40863c39e9a453e7d93cf824d051f704dee7850b5a9b5bf83097ddaf51129d7020275e10516fb377afd6ada09a469d050bf042e8b884a1251128526e40630601b0f55300bb7b035a35fe10da806778dbd376d9080e9d195276a6888b9381d31a24230175c1c0fac3fd9f05436f34430abfdf56b44065779e730325f5c56454f50289df6637e41014a5df37ca0a967c792223da0a3f919b9f2abe8f2755ae8cad6015944ba473b60d53371488d3924708b8905f4dabada85ba565dcb5c9fbff41959951a69c074b1cad857d1d1b00844dbc9c5bc68c722e37648a9cacba9ff34c52737c394a41d27159d4f7619e9b02155bb057a046c228a38f608b15a46b0b71feea39ed902c480912b80417a18d8c0893f60e664a6ee9a63af69d37fe0b094d556fbf7696bd1f4ff7f1f38d71f2344e2adfafa0110e127805d5c711dfeff2e731d9f13421a706c906028310ad0c3e6724854ab3259e218fa512edc0193e05c58012b5b33a10bee0bfab9103a169358a97c6b84d994f809185cbd139f16f9c174306d5e6b792272929e28e347df32cc4d88e4d17b4a963c6c3266f475b0fd58d53059a4a2041440427a1f3fbe810450ecaa6e130aa9c562</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">Hey, password is required here.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目介绍 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K个一组翻转链表</title>
      <link href="/posts/reverse-nodes-in-k-group.html"/>
      <url>/posts/reverse-nodes-in-k-group.html</url>
      
        <content type="html"><![CDATA[<h1>K个一组翻转链表</h1><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&amp;envId=top-100-liked">LeetCode原题链接</a></p><h2 id="题目描述">题目描述</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="示例1"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="示例2"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p>**进阶：**你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h2 id="题目分析">题目分析</h2><p>这题难度被划归为困难，其实显然是不能达到困难题的难度的，只不过如果不习惯封装编程，单独将反转链表的方法单独写的话可能会有一些边界类型的问题出现。不过提到了需要使用 <code>O(1)</code> 额外内存空间，前置题目为反转链表，题目链接为：<a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">反转链表</a>，只不过反转链表提到可以使用递归或者迭代的方式，但是递归的方式显然需要使用系统栈，无法实现额外内存空间需求，所以这题几乎已经锁定使用迭代的方式进行反转。</p><p>首先我们先尝试做一下反转链表这道题目</p><h3 id="反转链表">反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="示例1"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><p>官方定义的链表结构还是比较简单的，没有要用户自己定义链表，有些企业的面试题是需要自己定义的嘛，所以我们也简单自己定义一下，防患未然了属于是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*定义链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line"><span class="comment">//空参构造方法</span></span><br><span class="line">ListNode()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ListNode(<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="built_in">this</span>.val=val;</span><br><span class="line">&#125;</span><br><span class="line">ListNode(<span class="type">int</span> val,ListNode next)&#123;</span><br><span class="line"><span class="built_in">this</span>.val=val;</span><br><span class="line"><span class="built_in">this</span>.next=next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现任务之前，先简单实现一个输入获取和结果打印的方法，便于本地自行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">readDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    String[] vals = sc.nextLine().replaceAll(<span class="string">&quot;^\\[*|\\]*$&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span>(String val:vals)&#123;</span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(Integer.valueOf(val));</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printListNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> != head)&#123;</span><br><span class="line">        sb.append(head.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是正常实现了，我们分为两种方式实现吧，首先是比较简单的递归的方式实现，递归的方式就是不断把后半段反转然后作为前半段的头部分。</p><p>我的代码可能有一点唐氏，讲得也没有官方的好，所以我贴在这里，简单介绍一下，一些注释基本代表了我的想法，需要注意的只有一点，就是需要先翻转后面的节点，然后再和前面的节点拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表的递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 后面需要反转的链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pre 已经完成反转的前半部分的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转完之后链表的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseListDFS</span><span class="params">(ListNode head,ListNode pre)</span>&#123;</span><br><span class="line">  <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//定义递归终点，也就是最后一个节点，直接把它和它前面的那个节点拼起来然后返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head.next)&#123;</span><br><span class="line">      head.next=pre;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果不是递归终点，这部分就需要理解一下</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//首先是将后面部分翻转！</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> reverseListDFS(head.next, head);</span><br><span class="line">      <span class="comment">//然后将改节点的next改为pre，拼接起来，顺序一定不能错</span></span><br><span class="line">        head.next = pre;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reverseListDFS(head,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让我们来实现一下迭代的方式，迭代主要还是双指针的思路，其实相对而言思路比递归更容易理解一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表迭代实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转完之后链表的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseListIter</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//定义双指针，这个定义是有技巧的，因为头节点的next要是null</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//依次设置前指针的next为后指针</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> != pre)&#123;</span><br><span class="line">        ListNode tmp=pre.next;</span><br><span class="line">        pre.next = lst;</span><br><span class="line">        lst = pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前指针为空时，后指针所指着的位置就是最后一个Node，也就是我们所需要的head</span></span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后反转链表部分我们就基本讲完了，但是迭代这个部分的代码在后面我们还需要进行一点小小的修改，为什么呢，因为K个一组反转链表，链表的终点不是null，而是我们需要的终点是第K个节点。</p><p>接下来就是K个一组反转链表的任务，简单来说，我们只需要把任务拆成K个反转链表的子任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseSubList</span><span class="params">(ListNode head, ListNode last)</span> &#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//定义双指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//依次设置前指针的next为后指针</span></span><br><span class="line">    <span class="keyword">while</span>(last != lst)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        pre.next = lst;</span><br><span class="line">        lst = pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//当k=1的时候，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == k) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//为了统一以及便于找到头，我们定义一个伪头部，其实这是很常用的方法</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fake_head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    fake_head.next=head;</span><br><span class="line">    <span class="comment">//如果k不等于1，接下来我们就需要定义一个节点，这个节点所需要做的事情就是找到每组的第K个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">findK</span> <span class="operator">=</span> fake_head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst_one</span> <span class="operator">=</span> fake_head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里只需要判断findK是不是空，因为它一直走在其余两个交换位置的指针的前面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span>!=findK)&#123;</span><br><span class="line">        <span class="comment">//如果不是第K个，直接后移，不做处理</span></span><br><span class="line">        <span class="keyword">if</span>(count!=k)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            findK=findK.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是第K个</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//重置寻找循环</span></span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//首先是获得子段的头，子段的尾就是findK</span></span><br><span class="line">            ListNode child_head=lst_one.next;</span><br><span class="line">            ListNode K_next=findK.next;</span><br><span class="line">            <span class="comment">//然后进行子段反转，这里会把它的头尾都断开，所以之后就需要重新拼接</span></span><br><span class="line">            reverseSubList(child_head,findK);</span><br><span class="line">            <span class="comment">//然后将前面的子段和尾节点拼接</span></span><br><span class="line">            lst_one.next=findK;</span><br><span class="line">            <span class="comment">//将头节点和后面的节点拼接</span></span><br><span class="line">            child_head.next=K_next;</span><br><span class="line">            <span class="comment">//重置last_one和findK</span></span><br><span class="line">            lst_one = child_head;</span><br><span class="line">            findK = child_head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fake_head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只能说，很优雅，但是还是建议大家看看官解，我写的很简陋。</p>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hot100 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
