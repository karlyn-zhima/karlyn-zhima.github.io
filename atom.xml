<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhima の blog</title>
  
  
  <link href="https://www.karlyn.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.karlyn.xyz/"/>
  <updated>2025-03-31T16:14:11.278Z</updated>
  <id>https://www.karlyn.xyz/</id>
  
  <author>
    <name>karlyn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过Canal订阅binlog自动更新Redis</title>
    <link href="https://www.karlyn.xyz/posts/canal_binlog.html"/>
    <id>https://www.karlyn.xyz/posts/canal_binlog.html</id>
    <published>2025-03-31T16:08:49.000Z</published>
    <updated>2025-03-31T16:14:11.278Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>这是我扩充我的项目的一个点，有点摸着石头过河的意思，可能很多思路也不够企业化，然后技术选型什么的也不够正确。</p><h1>MySQL开启binlog并且设定为RAW模式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like&#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">| Variable_name                   | Value                       |</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">| log_bin                         | ON                          |</span><br><span class="line">| log_bin_basename                | /var/lib/mysql/binlog       |</span><br><span class="line">| log_bin_index                   | /var/lib/mysql/binlog.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                         |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                         |</span><br><span class="line">| sql_log_bin                     | ON                          |</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">6 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>这里我简单看了一下我的库，不知道为什么是自己开启的，但是还是准备去配置文件看一眼是不是配置了server_id</p><p>这里进去</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/my</span>sql<span class="comment"># vi my.cnf</span></span><br></pre></td></tr></table></figure><p>加一下配置开启binlog就行了<br>令人烦躁时的我50块的京东云服务器的2G内存快要顶不住压力了：）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 开启 binlog</span></span><br><span class="line"><span class="attr">log-bin</span> = /var/log/mysql/mysql-bin.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 server-id（每个 MySQL 实例必须唯一）</span></span><br><span class="line"><span class="attr">server-id</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：设置 binlog 格式（ROW 是推荐的格式）</span></span><br><span class="line"><span class="attr">binlog_format</span> = ROW</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：设置 binlog 过期时间（单位为天）</span></span><br><span class="line"><span class="attr">expire_logs_days</span> = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：限制 binlog 文件大小（单位为字节，默认值为 1GB）</span></span><br><span class="line"><span class="attr">max_binlog_size</span> = <span class="number">100</span>M</span><br></pre></td></tr></table></figure><h1>Canal下载并配置</h1><p>然后是下载Canal，技术选型方面，其实我能选择的不太多，主要就是Canal 和 Debezium。</p><p>我选择Canal的原因大抵如下：</p><p>轻量级：Canal专注于 MySQL 数据库的 CDC，架构相对简单，更加轻量化。</p><p>独立于 Kafka：不像 Debezium一样，最初专为Kafka设计。</p><p>易于部署：Canal 的部署相对简单，尤其是对单一数据库的监听、</p><p>下载然后一键tar-zxf之后进行一下简单的配置，在提供的样例里修改。</p><h2 id="修改conf-example-instance-properties">修改conf/example/instance.properties</h2><h2 id="mysql-serverId">mysql serverId</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canal.instance.mysql.slaveId</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">## 这个要和数据库的server-id不相同</span></span><br><span class="line"><span class="attr">canal.instance.master.address</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">3306</span> </span><br><span class="line"><span class="attr">canal.instance.dbUsername</span> = zhima  </span><br><span class="line"><span class="attr">canal.instance.dbPassword</span> = ********</span><br></pre></td></tr></table></figure><p>配置完之后可以自己先启动一下，就很简单，bash /bin/startup.sh</p><p>然后稍微修改一下数据库中的一行，之后看一下example输出的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2025-03-31 22:00:50.725 [destination = example , address = /127.0.0.1:3306 , EventParser] ERROR com.alibaba.otter.canal.common.alarm.LogAlarmHandler - destination:example[com.alibaba.otter.canal.parse.exception.CanalParseException: java.io.IOException: connect /127.0.0.1:3306 failure</span><br><span class="line">Caused by: java.io.IOException: connect /127.0.0.1:3306 failure</span><br><span class="line">    at com.alibaba.otter.canal.parse.driver.mysql.MysqlConnector.connect(MysqlConnector.java:85)</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.mysql.MysqlConnection.connect(MysqlConnection.java:104)</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.mysql.MysqlEventParser.preDump(MysqlEventParser.java:89)</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.AbstractEventParser$1.run(AbstractEventParser.java:171)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:750)</span><br><span class="line">Caused by: java.io.IOException: Error When doing Client Authentication:ErrorPacket [errorNumber=1698, fieldCount=-1, message=Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27;, sqlState=28000, sqlStateMarker=#]</span><br><span class="line">    at com.alibaba.otter.canal.parse.driver.mysql.MysqlConnector.negotiate(MysqlConnector.java:325)</span><br><span class="line">    at com.alibaba.otter.canal.parse.driver.mysql.MysqlConnector.connect(MysqlConnector.java:81)</span><br><span class="line">    ... 4 more</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果像这样一般是配置有问题没连上，修改一下就行，之后成功连上之后就可以自己写一个客户端来进行调用啦，下面这段代码用来测试就很合适。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.karlyn.dogie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.*;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCanalClientExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 连接信息配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hostname</span> <span class="operator">=</span> <span class="string">&quot;*.*.*.*&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">11111</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destination</span> <span class="operator">=</span> <span class="string">&quot;example&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        <span class="type">CanalConnector</span> <span class="variable">connector</span> <span class="operator">=</span> CanalConnectors.newSingleConnector(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(hostname, port), destination, username, password</span><br><span class="line">        );</span><br><span class="line">        System.out.println(<span class="string">&quot;连接创立成功&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connector.connect();</span><br><span class="line">            connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line">            connector.rollback();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> connector.getWithoutAck(batchSize); <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">batchId</span> <span class="operator">=</span> message.getId();</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> message.getEntries().size();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有拿到数据</span></span><br><span class="line">                <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;message[batchId=%s, size=%s] \n&quot;</span>, batchId, size);</span><br><span class="line">                    printEntry(message.getEntries());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                connector.ack(batchId); <span class="comment">// 提交确认</span></span><br><span class="line">                <span class="comment">// connector.rollback(batchId); // 处理失败, 回滚数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEntry</span><span class="params">(List&lt;Entry&gt; entries)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChange = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(),</span><br><span class="line">                        e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">EventType</span> <span class="variable">eventType</span> <span class="operator">=</span> rowChange.getEventType();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class="line">                    entry.getHeader().getLogfileName(),</span><br><span class="line">                    entry.getHeader().getLogfileOffset(),</span><br><span class="line">                    entry.getHeader().getSchemaName(),</span><br><span class="line">                    entry.getHeader().getTableName(),</span><br><span class="line">                    eventType));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据变化</span></span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowChange.getRowDatasList()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printColumn</span><span class="params">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            System.out.println(column.getName() + <span class="string">&quot; : &quot;</span> + column.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后开始和消息队列和Springboot整合啦</p><h2 id="修改canal配置canal-properties">修改canal配置canal.properties</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">canal.serverMode = rabbitMQ</span><br><span class="line"></span><br><span class="line">##################################################</span><br><span class="line">#########           RabbitMQ         #############</span><br><span class="line">##################################################</span><br><span class="line">rabbitmq.host = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">rabbitmq.virtual.host = /</span><br><span class="line">rabbitmq.exchange = canal-exchange</span><br><span class="line">rabbitmq.username = root</span><br><span class="line">rabbitmq.password = <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>同时继续修改instance.properties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mq config</span></span><br><span class="line"><span class="comment"># canal.mq.topic=example</span></span><br><span class="line"><span class="attr">canal.mq.topic</span>=canal-routing-key</span><br></pre></td></tr></table></figure><p>然后重启canal服务</p><h1>Springboot集成</h1><p>消息订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.karlyn.dogie.Canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanalProvider</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">canalQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * durable:是否持久化，默认false，持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在；暂存队列：当前连接有效</span></span><br><span class="line"><span class="comment">         * exclusive:默认为false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable</span></span><br><span class="line"><span class="comment">         * autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(RabbitConstant.CanalQueue, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机，这里使用直连交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DirectExchange <span class="title function_">canalExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(RabbitConstant.CanalExchange, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定交换机和队列，并设置匹配键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingCanal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(canalQueue()).to(canalExchange()).with(RabbitConstant.CanalRouting);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息消费，我这里写的比较简单，如果消息消费失败之后我会把它重新放回消息队列，但是这时候消息队列会一直把这个消息发给消费者，所以这块还需要优化一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.karlyn.dogie.Canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.type.TypeReference;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.entity.enums.UserContactStatusEnum;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.entity.po.UserContact;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.entity.query.UserContactQuery;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.mappers.UserContactMapper;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.redis.RedisComponent;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.util.JsonUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.AmqpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Header;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Canal消息消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = RabbitConstant.CanalQueue)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanalConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserContactMapper userContactMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisComponent redisComponent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CanalConsumer</span><span class="params">(UserContactMapper userContactMapper, RedisComponent redisComponent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userContactMapper = userContactMapper;</span><br><span class="line">        <span class="built_in">this</span>.redisComponent = redisComponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Listener</span><span class="params">(String message, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> tag)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到canal消息：&quot;</span> + message);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        Map&lt;String, Object&gt; msg = objectMapper.readValue(message,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDdl</span> <span class="operator">=</span> (<span class="type">boolean</span>) msg.get(<span class="string">&quot;isDdl&quot;</span>);</span><br><span class="line">        <span class="comment">// 不处理DDL事件</span></span><br><span class="line">        <span class="keyword">if</span> (isDdl) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">database</span> <span class="operator">=</span> (String) msg.get(<span class="string">&quot;database&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> (String) msg.get(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> (String) msg.get(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">        List&lt;LinkedHashMap&gt; data = (List&lt;LinkedHashMap&gt;) msg.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(database.equals(<span class="string">&quot;dogie&quot;</span>)&amp;&amp;table.equals(<span class="string">&quot;user_contact&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (LinkedHashMap s : data) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">UserId</span> <span class="operator">=</span> (String) s.get(<span class="string">&quot;user_id&quot;</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;更新&#123;&#125;的联系人缓存&quot;</span>,UserId);</span><br><span class="line">                    <span class="type">UserContactQuery</span> <span class="variable">userContactQuery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserContactQuery</span>();</span><br><span class="line">                    userContactQuery.setUserId(UserId);</span><br><span class="line">                    userContactQuery.setStatus(UserContactStatusEnum.FRIEND.getStatus());</span><br><span class="line">                    List&lt;UserContact&gt; userContactList = <span class="built_in">this</span>.userContactMapper.selectList(userContactQuery);</span><br><span class="line">                    List&lt;String&gt; contactIds = userContactList.stream().map(item-&gt;item.getContactId()).collect(Collectors.toList());</span><br><span class="line">                    <span class="built_in">this</span>.redisComponent.cleanUserContact(UserId);</span><br><span class="line">                    <span class="keyword">if</span>(!contactIds.isEmpty())&#123;</span><br><span class="line">                        <span class="built_in">this</span>.redisComponent.addUserContactBatch(UserId, contactIds);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(tag,<span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">                channel.basicNack(tag,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;这是我扩充我的项目的一个点，有点摸着石头过河的意思，可能很多思路也不够企业化，然后技术选型什么的也不够正确。&lt;/p&gt;
&lt;h1&gt;MySQL开启binlog并且设定为RAW模式&lt;/h1&gt;
&lt;figure class=&quot;highlight plaint</summary>
      
    
    
    
    <category term="项目" scheme="https://www.karlyn.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="消息队列" scheme="https://www.karlyn.xyz/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="Canal" scheme="https://www.karlyn.xyz/tags/Canal/"/>
    
    <category term="binlog" scheme="https://www.karlyn.xyz/tags/binlog/"/>
    
  </entry>
  
  <entry>
    <title>关于多线程的一些实验</title>
    <link href="https://www.karlyn.xyz/posts/thread.html"/>
    <id>https://www.karlyn.xyz/posts/thread.html</id>
    <published>2025-03-30T11:13:02.000Z</published>
    <updated>2025-03-30T15:14:17.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>都是做的比较浅显的一些实验，很多问题来自于小林coding，很多内容其实挺八股的，但是我的记忆偶尔会带有一些内存特性，关机就忘了，所以现在想办法通过一点实验和手敲代码落一下盘。</p><h1 id="正式内容"><a href="#正式内容" class="headerlink" title="正式内容"></a>正式内容</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>线程和进程的区别，这个问题在很多地方都会遇到，无论是在操作系统还是在Java多线程。</p><p>其实两者最大的区别就是是否享有独立的执行环境。</p><p>我们以Java举例，JVM的运行时内存主要包括这样五块：</p><ol><li>虚拟机栈</li><li>堆（常量池什么的其实也在堆里）</li><li>元空间</li><li>本地方法栈(Native)</li><li>程序计数器</li></ol><p>一个进程会独立的享有这全部的五个运行时环境，而线程则不是，一个进程创建一个线程，这个线程会获得自己独立的虚拟机栈、程序计数器，对于任意该进程创建的线程，其余三者都是共用的。</p><p>举个🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepTry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">      <span class="comment">//这个StringBuilder是创建在进程堆上的，所以他是会被共享的，创建线程的时候会拷贝一个引用副本</span></span><br><span class="line">      <span class="comment">//所以任何线程都可以操作并修改他，修改的并不是线程自己创建的，而是进程所创建的</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; bq =<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000L</span>, TimeUnit.SECONDS,bq);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (sb)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;I am Thread2\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Future&lt;?&gt; feature2 =  threadPoolExecutor.submit(task2);</span><br><span class="line">        feature2.get();</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        threadPoolExecutor.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，线程是操作系统运算调度的最小单位，因为线程之间的资源共享性质，导致它的上下文切换的开销更小。同时，他们可以通过访问全局变量或者静态变量来通信。</p><p>进程的创建和销毁需要创建和销毁上述的全部资源，而进程只需要创建和销毁程序计数器和对应的运行时栈即可。</p><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>很多面经喜欢把这个问题总结为四类，包括继承Thread、实现Runable和FutureTask、实现Callable、使用线程池，但其实归根到底来说还是三类，因为FutureTask这个抽象类实现了RunnableFuture接口，RunnableFuture这个接口继承了Future接口和Runable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Revision notes: This differs from previous versions of this</span></span><br><span class="line"><span class="comment">     * class that relied on AbstractQueuedSynchronizer, mainly to</span></span><br><span class="line"><span class="comment">     * avoid surprising users about retaining interrupt status during</span></span><br><span class="line"><span class="comment">     * cancellation races. Sync control in the current design relies</span></span><br><span class="line"><span class="comment">     * on a &quot;state&quot; field updated via CAS to track completion, along</span></span><br><span class="line"><span class="comment">     * with a simple Treiber stack to hold waiting threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，创建线程有两件事情，1.确定线程要做的事情，也就是实现run或者call方法。2.启动线程</p><p>所以我们可以直接用一个类继承Thread然后重写run方法，就像这样！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello zhima.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread3</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread3</span>();</span><br><span class="line">thread3.start();</span><br></pre></td></tr></table></figure><p>或者就像上面那样实现Runable接口。</p><p>关于为什么要使用FutureTask这个抽象类，其实主要是希望获得线程的返回值。</p><p>就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread4</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">114514</span>,<span class="number">114515</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Thread4</span>());</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">t4.start();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">rand</span> <span class="operator">=</span> ft.get();</span><br><span class="line">System.out.println(rand);</span><br><span class="line"><span class="comment">//114514</span></span><br></pre></td></tr></table></figure><p>如果用线程池其实创建方法也很多，可以通过下面几种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建大小固定的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//也可以创建一个</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//也可以直接new一个ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">//要指定的东西就比较多了，包括核心线程数，最大的线程数，非核心空闲线程AliveTime，AliveTime的单位，以及用来存储等待任务的阻塞队列</span></span><br><span class="line"><span class="comment">//如果阻塞队列用ArrayBlockingQueue的话还要指定最大大小</span></span><br><span class="line">BlockingQueue&lt;Runnable&gt; blockingQueue =<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executorService2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000L</span>, TimeUnit.SECONDS,blockingQueue);</span><br></pre></td></tr></table></figure><p>还有八股里面常问的start和run的区别，run其实就是调用一下你定义的线程要执行的方法，而start才是启动线程。</p><p>线程的状态包括：new、runable、blocked、waiting、timed_waiting、terminated</p><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><p>这是我决定写这篇博客的出发点，主要是我一开始竟然不知道sleep不会释放当前占用的资源，就比如说我用synchronized关键字同步住了一个资源StringBuilder。</p><p>如果我在同步块内调用了一下sleep(0)，虽然线程会放弃对该时间片的占用，但是并不会释放资源。</p><p>但是如果在同步块内使用wait()，就会放弃对当前资源和时间片的占用。</p><p>做个简单的实验，就是最开始那部分的代码，我们先通过实验进行尝试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepTry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; bq =<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000L</span>, TimeUnit.SECONDS,bq);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (sb)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sb.append(<span class="string">&quot;I am Thread1\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (sb)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;I am Thread2\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Future&lt;?&gt; feature1 =  threadPoolExecutor.submit(task1);</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        Future&lt;?&gt; feature2 =  threadPoolExecutor.submit(task2);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="comment">//feature1.get();</span></span><br><span class="line">        <span class="comment">//feature2.get();</span></span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        threadPoolExecutor.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在同步块里sleep了2s，如果释放了资源，一定是够第二个线程把自己的内容加进去的。</p><p>为了让主进程等待两个线程都执行完，我加了一个两步计数器CountDownLatch，每个线程执行完就减一。用被注释掉的两行get其实也可以。</p><p>但是实际结果是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line"><span class="selector-tag">I</span> am Thread1</span><br><span class="line"><span class="selector-tag">I</span> am Thread2</span><br></pre></td></tr></table></figure><p>显然，资源并没有得到释放</p><p>此时别的代码都不作修改，在两个线程的同步块内分别调用wait()和notifyAll()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepTry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; bq =<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000L</span>, TimeUnit.SECONDS,bq);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (sb)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sb.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sb.append(<span class="string">&quot;I am Thread1\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (sb)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;I am Thread2\n&quot;</span>);</span><br><span class="line">                    sb.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Future&lt;?&gt; feature1 =  threadPoolExecutor.submit(task1);</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        Future&lt;?&gt; feature2 =  threadPoolExecutor.submit(task2);</span><br><span class="line">        <span class="comment">//feature1.get();</span></span><br><span class="line">        <span class="comment">//feature2.get();</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        threadPoolExecutor.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line"><span class="selector-tag">I</span> am Thread2</span><br><span class="line"><span class="selector-tag">I</span> am Thread1</span><br></pre></td></tr></table></figure><p>资源成功释放，第二个线程也成功写入。</p><p>如果第二个线程不notify，而主进程又等着线程1减少计数器，那么进程就会一直等待。</p><p>所以此时我们wait的时候可以加个timeout的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.wait(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>所以很多八股其实总结的并不好，wait并不一定需要notify才能唤醒，也可以主动设定timeout，超时也会唤醒。</p><h4 id="小小总结一下sleep和wait"><a href="#小小总结一下sleep和wait" class="headerlink" title="小小总结一下sleep和wait"></a>小小总结一下sleep和wait</h4><ol><li><p>sleep方法属于Thread类，是一个静态方法，作用是让当前线程进入sleep状态；而wait是一个实例方法，属于Object类，必须被一个初始化了的实力对象调用</p></li><li><p>如果处于同步块内，sleep不会释放资源，但是wait会释放资源</p></li><li><p>sleep可以不在同步块内调用，但是wait一定要在同步块内调用。也就是说，你要释放这个资源，你必须持有这个资源的锁，否则就会报错如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: java.lang.IllegalMonitorStateException: current thread is not owner</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.report(FutureTask.java:<span class="number">122</span>)</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:<span class="number">191</span>)</span><br><span class="line">at SleepTry.main(SleepTry.java:<span class="number">44</span>)</span><br><span class="line">Caused by: java.lang.IllegalMonitorStateException: current thread is not owner</span><br><span class="line">at java.base/java.lang.Object.wait(Native Method)</span><br><span class="line">at java.base/java.lang.Object.wait(Object.java:<span class="number">338</span>)</span><br><span class="line">at SleepTry$<span class="number">1.</span>run(SleepTry.java:<span class="number">15</span>)</span><br><span class="line">at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">539</span>)</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">264</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1136</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">635</span>)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:<span class="number">833</span>)</span><br></pre></td></tr></table></figure></li></ol><ol><li>唤醒机制，sleep只能等待超时唤醒，但是wait既可以超时唤醒，也可以通过被notify()或者notifyAll()唤醒</li></ol><p>最后这里补充一下notify和notifyAll的区别，这是小林coding上写的，说的特别形象</p><p>notify：唤起一个线程，其他线程还处于waiting状态，如果这个线程结束的时候没有notify，那么其他线程只能继续等待到超时或被中断。而且notify说是随机唤醒，但是在hotspot虚拟机里是先进先出的唤醒。</p><p>notifyAll：所有线程都被唤醒，然后进入资源争夺环节，喜闻乐见的BLOCKED状态</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>之前说了线程的六个状态，这里再提醒自己默写一下：</p><p>NEW、RUNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</p><p>BLOCKED和WAITING其实还挺难分清楚的，我总结为下：</p><p>虽然都是阻塞在那里，但是BLOCKED是因为资源竞争导致的阻塞</p><p>WAITING是线程无限期地等待另一个线程执行特定操作，比如上面所使用的CountDownLatch，如果调用await()方法，其实是进入WAITING状态，和调用wait方法类似。</p><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><p>老生常谈，就是Java官方不建议使用Thread.stop()这种方式来停止。</p><p>有很多种方法包括</p><ol><li><p>使用volatile关键字来修饰一个boolean变量，线程关注到boolean变量自己内部停止</p></li><li><p>调用线程中断Thread.interrupt()，然后线程内部检测当前线程是否为中断状态或者触发可中断操作来响应中断。</p><p>可触发中断操作是指sleep或者wait等阻塞操作，如果这时候收到中断请求会直接抛中断异常的。</p></li><li><p>通过Future管理任务，Future接口是一个可以主动停止任务的接口，Future.cancel()</p></li><li><p>关闭资源</p></li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="volatile关键字和synchronized关键字"><a href="#volatile关键字和synchronized关键字" class="headerlink" title="volatile关键字和synchronized关键字"></a>volatile关键字和synchronized关键字</h3><p>这两个关键字总是被拿出来说，但其实两者的作用差距还是挺大的。</p><p>volatile的作用主要体现在禁止指令重排导致的修改不可见。</p><p>这个🌰其实挺不好举的，我试着看看能不能出现。失败了，很难复现啊，因为并不知道虚拟机底层是如何指令重排和优化的。</p><p>但是volatile关键字的目的所在，就是为了让线程知道一个变量它变化了，能感知到它的变化，借由此线程之间可以相互通信。</p><p>然后说说volatile关键字的作用域，volatile关键字主要作用于变量声明上，更多的用于<strong>实例变量</strong>或<strong>静态变量</strong>，所以局部变量声明无意义。</p><h3 id="synchronized关键字和-ReentrantLock"><a href="#synchronized关键字和-ReentrantLock" class="headerlink" title="synchronized关键字和 ReentrantLock"></a>synchronized关键字和 ReentrantLock</h3><p>接下来就是synchronized关键字，其实它更应该和ReentrantLock放在一起比较才适合，所以我们把它挪到下面来</p><p>synchronized关键字主要用于声明同步，也就是给资源加锁。</p><p>与ReentrantLock相同的，synchronized也是一个可重入锁，也就是同一个线程内再次上锁也可以获得资源。</p><p>synchronized是Java提供的原子内置锁，也被称为监视器锁。</p><p>使用synchronize关键字修饰的代码块在编译的时候前后会分别加上monitorenter和monitorexit。</p><p>这个执行到monitorenter的时候会尝试获取资源，如果获取到资源就把计数器加一，执行到monitorexit的时候就把计数器减一。为0的时候代表是可获取的。</p><p>接下来是synchronized关键字的作用域，其实挺复杂的：</p><ol><li><p>作用于类的实例方法上，那就是锁住了当前实例，同一时间只能有一个线程访问该方法的任何 <code>synchronized</code> 实例方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">beBlocked</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getB</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">beBlocked</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">beBlocked</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;());</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        test.getA();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span>test.getB();</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这段代码为例，调用getA方法sleep的那10s，另一个线程是没有办法获得到哪怕是getB方法的返回值的。</p></li><li><p>作用于静态方法，那就会锁住类对象，同一时间只能有一个线程访问该方法的任何 <code>synchronized</code> 静态方法。</p></li><li><p>作用于代码块，也就是常用的synchronized(){}范式，括号里可以为Object或者this，也可以是Class对象</p></li></ol><p>ReentrantLock相比于synchronized更为精细化。</p><p>它实现了两个接口，Lock接口和序列化接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">     * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">     * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同步的实现主要依赖于继承自AbstractQueuedSynchronizer类（AQS）类的Sync类</p><p>ReentrantLock是可重入锁，从名字就可以看出来，每次获取都需要相应的释放操作，锁内部维护了一个计数器来记录获取的次数。这点和synchronized关键字很像。</p><p>实例化ReentrantLock的时候可以选择是否启用公平锁。公平锁会按照请求顺序授予锁，而非公平锁则允许插队（即新来的线程可能在等待中的线程之前获得锁）。默认是非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时ReentrantLock支持中断响应，也就是在等待锁的时候在同步块内响应打断。</p><p>同时也支持非阻塞式的获取锁，tryLock，如果不能获得锁，立刻返回，也可以传入等待时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">reentrantLock.lockInterruptibly();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> reentrantLock.tryLock(<span class="number">10</span>, TimeUnit.MICROSECONDS);</span><br></pre></td></tr></table></figure><h3 id="其他的锁"><a href="#其他的锁" class="headerlink" title="其他的锁"></a>其他的锁</h3><p>synchronized和ReentrantLock都是排他锁，其实还有很多其他锁的类型。</p><p>像是ReadWriteLock，写锁是独占锁，但是读锁是共享锁。</p><p>以及一些概念性的锁，乐观锁和悲观锁。</p><p>乐观锁其实本质上就是假设资源没人用，有人用了我再重来。悲观锁就是synchronized和ReentrantLock这样的锁，一定要独占了再去操作。</p><p>自旋锁主要是靠CAS实现的。CAS全称Compare And Set。</p><p>涉及三个参数：内存位置（V）、预期原值（A）和新值（B）。CAS 的执行逻辑如下：</p><ol><li>检查内存位置 V 中的值是否等于预期原值 A。</li><li>如果相等，则将内存位置 V 的值更新为新值 B，并返回成功。</li><li>如果不相等，说明有其他线程已经修改了该位置的值，则不进行任何操作，并返回失败。</li></ol><p>这其实是乐观锁的一种实现。Java的原子类比如AtomicInteger就提供这种类型的方法：compareAndSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to &#123;<span class="doctag">@code</span> newValue&#125;</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> == expectedValue&#125;,</span></span><br><span class="line"><span class="comment"> * with memory effects as specified by &#123;<span class="doctag">@link</span> VarHandle#compareAndSet&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedValue the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment"> * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetInt(<span class="built_in">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h3><p>sychronized的锁升级过程：</p><p>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</p><p>偏向锁是JAVA1.6引入的，当一个线程拿到锁之后，会记录它的线程ID，如果没有竞争时，只需要比较记录的ID与自己是否一致，一致直接获得锁，不需要CAS操作。</p><p>当有锁竞争的时候，偏向锁升级为轻量级锁。这时候的锁通过CAS实现，允许自旋。</p><p>当竞争激烈的时候，轻量级锁升级为重量级锁，系统挂起线程而不是线程自旋。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>全名为抽象同步队列，实现同步的重要底层之一。</p><p>主要维护一个阻塞队列和一个state。如果state为0或者为同线程（可重入锁），则可获得锁，计数器+1；</p><p>竞争失败的线程加入到阻塞队列中去，如果是公平锁，新来的线程直接加入到阻塞队列中去</p><h3 id="非公平锁为什么比公平锁吞吐量大"><a href="#非公平锁为什么比公平锁吞吐量大" class="headerlink" title="非公平锁为什么比公平锁吞吐量大"></a>非公平锁为什么比公平锁吞吐量大</h3><p>因为非公平锁获取线程CAS如果获取到锁直接就拥有锁，不需要进行上下文切换。</p><h3 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h3><ol><li>互斥条件</li><li>拥有并等待</li><li>不可剥夺</li><li>资源依赖环路</li></ol>]]></content>
    
    
    <summary type="html">做点实验来稍微回顾一下Java多线程的常见问题</summary>
    
    
    
    <category term="代码实现" scheme="https://www.karlyn.xyz/categories/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="多线程" scheme="https://www.karlyn.xyz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>轻量云服务器结合RabbitMQ实现调用本地AI接口</title>
    <link href="https://www.karlyn.xyz/posts/deepseek.html"/>
    <id>https://www.karlyn.xyz/posts/deepseek.html</id>
    <published>2025-03-28T12:50:42.000Z</published>
    <updated>2025-03-28T14:47:53.799Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>我有一个仿微信的IM聊天项目，但是想做出一点新的东西，AI这个风口上所以还是想看看能不能做点AI接口的调用。但是直接调用官方接口意义不大，其实本质上来说，本地用Ollama部署完然后本地调用本地接口其实也不算很有难度的事情。</p><p>但是恰好我的IM项目就有这么一点——需要支持跨服务器之间的消息发送，所以设计了一个发布订阅的中间件来进行服务器上某个节点的消息扩散到其他服务器上，这样就天然支持了一件事情，就是A服务器的任务，如果被B服务器处理了，依然可以发送回到A服务器。</p><h2 id="简单展示">简单展示</h2><p>客户端发送消息给服务端，我的服务端是京东云的一个轻量级服务器，2G内存的那种。</p><p>现在我在客户端给服务端发一条消息，这时候我没关我本地的服务器啊，也就是说，我本地有个能处理AI图片的服务器挂在那里消费消息队列，这时候有正常的响应（别介意，不是32B，只是我当时觉得能跑，但是确实太慢了，后面我直接换1.5b了）</p><p><img src="/picture/ai_message.png" alt="客户端发消息"></p><p>这时候我们看看我京东云的日志，可以看到，有一条日志说消息队列消息增加，这是我在消息进入交换机的时候打的一个log，证明这条消息在不同服务器上扩散了，这时候就要去自己服务器上把这条消息发给对应的人，如果自己维护的WebSocketChannel里没有，就直接不管了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;$&#123;rabbit.queue.message&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Listener</span><span class="params">(String msg, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> tag)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">MessageSendDto</span> <span class="variable">sendDto</span> <span class="operator">=</span> JsonUtils.convertJson2Obj(msg, MessageSendDto.class);</span><br><span class="line">    log.info(<span class="string">&quot;消息队列收到消息&quot;</span>);</span><br><span class="line">    log.info(msg);</span><br><span class="line">    channelContextUtils.sendMessage(sendDto);</span><br><span class="line">    channel.basicAck(tag, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这条消息直接被丢弃了，但是因为是机器人，所以我们同时把它加到了机器人对应的消息队列里，但是我们京东云的日志并没有后续的处理。日志如下：</p><p><img src="/picture/jd_log.png" alt="京东云日志"></p><p>但是我们本地处理了，这是我本地运行jar包的输出</p><p><img src="/picture/local_log.png" alt="本地输出"></p><p>这是消息队列的消费情况。</p><p><img src="/picture/mq1.png" alt="消息队列"></p><p>这时候如果我们停掉本地的服务器，消息就会堆积在消息队列里等待有能力处理的服务器上线。</p><p><img src="/picture/mq2.png" alt="消息队列"></p><p>自然也不会给用户消息反馈。</p><p><img src="/picture/ai_message2.png" alt="客户端发消息"></p><h1>技术选型</h1><p>为了后续扩展方便，以及为了跨服务器聊天就是用了RabbitMQ的fanout扇出交换机来进行服务器之间的消息扩散，所以这次AI接口的技术扩展我们继续使用RabbitMQ，但是与之前选择使用发布订阅模型不同，我们这次选择的模式是生产者-消费者模型，也就是工作队列模式。</p><h2 id="这里简单介绍一下RabbitMQ的五种模式吧">这里简单介绍一下RabbitMQ的五种模式吧</h2><h3 id="简单模式">简单模式</h3><p>包含一个生产者，一个消费者，一个队列。生产者发送消息，消费者监听并消费消息。</p><p>这种模式的作用为：解耦，削峰填谷</p><p><img src="/picture/simple.png" alt="简单模式"></p><p>其实邮件、聊天都是这种场景的受众，只不过我们的服务器充当了一个消息队列的功能</p><h3 id="工作队列模式">工作队列模式</h3><p>这种模式就是一个生产者，一个队列，多个消费者，生产者源源不断往队列里放任务，消费者监听并处理任务。这样的模式也被称为能者多劳模式，能力越强的消费者消费的消息更多。</p><p><img src="/picture/work.png" alt="工作队列"></p><p>但是需要说的是，Springboot集成RabbitMQ，默认限制限制消费者一次从队列里获取250条消息，也就是说，消费者会一次预支250条消息，能力差的消费者这250条消息可能会处理很久。这点在我们的任务中表现的极为明显。我有一个7650GRE的卡和一张4090的卡，同时用这两个本地机器消费消息，显然7650GRE的能力比不上4090，250条消息要处理很久才能结束，但是我们的项目是一个实时聊天项目，可能4090处理完250条消息之后又会接着获取新的消息，导致后来的消息比前来的消息更快被模型处理和响应。</p><p>所以这里我们限制了每个消费者一次只能获取一条消息，处理完之后才能继续获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.listener.simple.prefetch=1</span><br></pre></td></tr></table></figure><p>这种模型最典型的应用场景就是抢红包，但是可能会出现红包余额被错误修改的情况，这种时候需要对红包余额加锁或者CAS操作。</p><h3 id="发布订阅模式">发布订阅模式</h3><p>发布订阅模式与工作队列模式不同在于，一条消息可以被多个消费者消费，这种在RabbitMQ中的实现就是fanout交换机，fanout交换机将获得的消息扇出到bind到它上面的每个消息队列中，每个消息队列被一个消费者消费，这样即可构成发布订阅模式。</p><p><img src="/picture/sub.png" alt="发布订阅模式"></p><p>这种模式最为经典的类比就是广播消息。但是这种模式和后面的路由模式的差别就在于无法过滤消息，也就是说要扇出就会扇出到全部绑定的队列。</p><h3 id="路由模式">路由模式</h3><p><img src="/picture/router.png" alt="路由模式"></p><p>路由模式根据生产者提供的路由key将消息发送到绑定到交换机上且路由key符合的消息队列。</p><h3 id="Topic模式">Topic模式</h3><p>主题模式，是由路由模式衍生出来的一种模式，路由模式并不支持模糊匹配，路由Key必须完全对应才会发送到对应的消息队列，但是主题模式不同，可以使用通配符匹配</p><p><img src="/picture/topic.png" alt="Topic模式"></p><ol><li><p>星号 和 井号代表通配符</p></li><li><p>星号匹配1个词, #匹配一个或多个词（* 匹配一级任意多个字符，# 匹配多级任意多个字符）</p></li></ol><p>​       例如：routingKey为&quot;user.#“，表示可以匹配&quot;user.add&quot;和&quot;user.add.log”。</p><p>​       routingKey为&quot;user.*“，表示可以匹配&quot;user.add”，对于&quot;user.add.log&quot;则无法匹配。</p><ol start="3"><li><p>路由功能添加模糊匹配</p></li><li><p>消息产生者产生消息,把消息交给交换机</p></li><li><p>交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费</p></li></ol><h2 id="具体实现">具体实现</h2><p>到这里我们复习完了五种模式，我们选择了工作队列模式，同时限定消费者只能消费一个队列。</p><p>所以我们在具体实现中，判断用户发来的消息是否是发给指定的机器人ID的，在这里我们设定为URobot，如果是这个ID，那么我们就将用户的UID以及用户发送的信息先简单打个信息表，打完信息表之后直接将这个信息封装为一个消息Dto，序列化之后加入到消息队列中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Constants.ROBOT_UID.equals(contactId)) &#123;</span><br><span class="line">    <span class="type">SysSettingDto</span> <span class="variable">sysSettingDto</span> <span class="operator">=</span> redisComponet.getSysSetting();</span><br><span class="line">    <span class="type">TokenUserInfoDto</span> <span class="variable">robot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenUserInfoDto</span>();</span><br><span class="line">    robot.setUserId(sysSettingDto.getRobotUid());</span><br><span class="line">    robot.setNickName(sysSettingDto.getRobotNickName());</span><br><span class="line">    <span class="type">ChatMessage</span> <span class="variable">robotChatMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatMessage</span>();</span><br><span class="line">    robotChatMessage.setContactId(sendUserId);</span><br><span class="line">    <span class="comment">//封装消息装到作为AI返回发送地址以及prompt准备加入到消息队列中去</span></span><br><span class="line">    robotChatMessage.setMessageType(MessageTypeEnum.CHAT.getType());</span><br><span class="line">    <span class="type">AIRabbitDto</span> <span class="variable">aIRabbitDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AIRabbitDto</span>();</span><br><span class="line">    aIRabbitDto.setChatMessage(robotChatMessage);</span><br><span class="line">    aIRabbitDto.setMessage(chatMessage.getMessageContent());</span><br><span class="line">    aIRabbitDto.setTokenUserInfoDto(robot);</span><br><span class="line">  <span class="comment">//将对应的消息投递到对应的消息队列中去</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;dogie.direct&quot;</span>,<span class="string">&quot;chat&quot;</span>,JsonUtils.convertObj2Json(aIRabbitDto));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  messageHandler.sendMessage(messageSend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们就需要设定对应的Listener了，这里我们存留了一点私心，就是我不希望用分离的方式来实现这个Listener，我最佳的愿望肯定是我有多个服务器，然后有的服务器有能力处理消息传递和AI功能，没有AI功能的服务器只负责对应的消息传递。所以我们给Listener的Bean使用了@ConditionalOnProperty注解，当服务器有能力处理AI对话的时候，就把配置文件中对应的字段设置为true，对应的服务器就会注册这个Listener的Bean，就会进一步调用listener方法，如果服务器没有能力，就不注册这个bean，自然也不会从消息队列里去取这个任务。</p><p>关于AI的调用，我看了挺多博客的，他们都说SpringAI可以继承了ollama的调用，我好像没找着，所以还是手搓了一个发消息的方法，就是使用OkHttpClient去调这个api，为了等待异步消息结束，我加了个CountDownLatch</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.karlyn.dogie.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.entity.dto.AIRabbitDto;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.entity.dto.OllamaResult;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.entity.dto.TokenUserInfoDto;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.entity.po.ChatMessage;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.service.ChatMessageService;</span><br><span class="line"><span class="keyword">import</span> com.karlyn.dogie.util.JsonUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> okhttp3.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.AmqpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Header;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;rabbit.listener.ai.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AIListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatMessageService chatMessageService;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ai.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer timeout;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ai.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String URL_OLLAMA;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ai.model&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String MODEL_DEEPSEEK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AIListener</span><span class="params">(ChatMessageService chatMessageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chatMessageService = chatMessageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;deepseek.queue&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Listener</span><span class="params">(String msg, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> tag)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AIRabbitDto</span> <span class="variable">aIRabbitDto</span> <span class="operator">=</span> JsonUtils.convertJson2Obj(msg, AIRabbitDto.class);</span><br><span class="line">        log.info(<span class="string">&quot;消费消息&quot;</span>);</span><br><span class="line">        log.info(aIRabbitDto.toString());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        getAiResult4Deepseek(aIRabbitDto.getMessage(),</span><br><span class="line">        aIRabbitDto.getChatMessage(),</span><br><span class="line">                            aIRabbitDto.getTokenUserInfoDto());</span><br><span class="line">          <span class="comment">//如果消费成功了，就手动确认一下</span></span><br><span class="line">         channel.basicAck(tag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//如果消费失败了就得Nack一下，把对应的消息重新塞回消息队列</span></span><br><span class="line">            channel.basicNack(tag, <span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getAiResult4Deepseek</span><span class="params">(String message, ChatMessage robotChatMessage, TokenUserInfoDto robot)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 设定头参数</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;prompt&quot;</span>, message);</span><br><span class="line">        params.put(<span class="string">&quot;model&quot;</span>, MODEL_DEEPSEEK);</span><br><span class="line">        params.put(<span class="string">&quot;stream&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        params.put(<span class="string">&quot;temperature&quot;</span>, <span class="number">0.7</span>);</span><br><span class="line">        params.put(<span class="string">&quot;top_p&quot;</span>, <span class="number">0.9</span>);</span><br><span class="line">        params.put(<span class="string">&quot;max_tokens&quot;</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonParams</span> <span class="operator">=</span> JsonUtils.convertObj2Json(params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Http请求</span></span><br><span class="line">        Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(URL_OLLAMA);</span><br><span class="line">        <span class="type">RequestBody</span> <span class="variable">body</span> <span class="operator">=</span> RequestBody.create(MediaType.parse(<span class="string">&quot;application/json; charset=utf-8&quot;</span>), jsonParams);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> builder.post(body).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置OkHttpClient</span></span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .connectTimeout(timeout, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(timeout, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(timeout, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">eventLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);<span class="comment">//定义一个只有1的计数器</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">resultBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); <span class="comment">// 用来收集消息</span></span><br><span class="line"></span><br><span class="line">        client.newCall(request).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;请求失败&quot;</span>, e);</span><br><span class="line">                eventLatch.countDown(); <span class="comment">// 请求失败计数器也减一</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> (<span class="type">ResponseBody</span> <span class="variable">responseBody</span> <span class="operator">=</span> response.body()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 读取响应内容</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">fullResponse</span> <span class="operator">=</span> responseBody.string();</span><br><span class="line">                          <span class="comment">//这里我是定义了一个对应的参数来解析这个responseBody</span></span><br><span class="line">                            <span class="type">OllamaResult</span> <span class="variable">aiResult</span> <span class="operator">=</span> JsonUtils.convertJson2Obj(fullResponse, OllamaResult.class);</span><br><span class="line">                            log.info(aiResult.getResponse());</span><br><span class="line">                            resultBuffer.append(aiResult.getResponse()); <span class="comment">//获取消息</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;获取失败&quot;</span>, response);</span><br><span class="line">                &#125;</span><br><span class="line">                eventLatch.countDown(); <span class="comment">// 请求成功计数器减一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        eventLatch.await(); <span class="comment">//等待计数器为0，也就是要么失败要么成功</span></span><br><span class="line">        String[] messages = resultBuilder.toString().split(<span class="string">&quot;&lt;/think&gt;\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(messages.length&lt;=<span class="number">1</span>) messages[<span class="number">0</span>]=<span class="string">&quot;服务器繁忙，请稍后再试&quot;</span>;</span><br><span class="line">        <span class="comment">// 如果成功直接把消息封装到Message里去，然后就可以把它继续加到消息队列里面去，但是是用来跨服务器通信的消息队列</span></span><br><span class="line">      <span class="comment">//后面这个bean就是做这件事情的，写表然后加消息队列</span></span><br><span class="line">        robotChatMessage.setMessageContent(messages[messages.length - <span class="number">1</span>]);</span><br><span class="line">        chatMessageService.saveMessage(robotChatMessage, robot);</span><br><span class="line">        <span class="keyword">return</span> resultBuilder.toString(); <span class="comment">//这个返回其实没什么用，是我在测试的时候打印的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">如果有一个部署在在公网上的服务端，但是算力不支持部署DeepSeek，但是本地有一个机器可以部署，可以尝试用RabbitMQ来提供消息的中转，充当RPC调用的服务。</summary>
    
    
    
    <category term="项目" scheme="https://www.karlyn.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="消息队列" scheme="https://www.karlyn.xyz/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>螺旋矩阵汇总</title>
    <link href="https://www.karlyn.xyz/posts/spiral-matrix.html"/>
    <id>https://www.karlyn.xyz/posts/spiral-matrix.html</id>
    <published>2025-03-21T11:15:48.000Z</published>
    <updated>2025-03-28T14:47:26.995Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>其实螺旋矩阵类的题目按理来说应该是简单的，因为是纯粹的模拟，只不大家定义方向的方式各有不同，以及方向的转换以及判断不够灵活，所以我们就简单试试！</p><h1>螺旋矩阵</h1><p><a href="https://leetcode.cn/problems/spiral-matrix/">LeetCode原题链接</a></p><h2 id="题目描述">题目描述</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="示例1"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[4,5,6]</span>,<span class="comment">[7,8,9]</span>]</span></span><br><span class="line">输出：<span class="comment">[1,2,3,6,9,8,7,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="示例2"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1,2,3,4</span>],[<span class="number">5,6,7,8</span>],[<span class="number">9,10,11,12</span>]]</span><br><span class="line">输出：[<span class="number">1,2,3,4</span>,<span class="number">8,12,11,10</span>,<span class="number">9,5,6,7</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h2 id="解读">解读</h2><p>其实这是很经典的顺时针螺旋矩阵了，只需要定义好方向，判断好数组边界以及已访问边界，就可以很顺利解决了。所以接下来我们简单看看实现。</p><p>最重要的事情其实是定义好方向，然后根据方向进行走步。</p><p>学会优雅的第一步，就是勇敢的派出一个探子，让它去尝试，如果它失败了我们就换方向走一步，否则就原方向走一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> m= matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//此处定义方向，按序分别为右、下、左、上，也就是我们螺旋的顺序</span></span><br><span class="line">        <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> dir_key=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; n * m; c++)&#123;</span><br><span class="line">            res.add(matrix[i][j]);</span><br><span class="line">            <span class="comment">//因为有范围为-100，100，标记已经访问过就可以用101</span></span><br><span class="line">            matrix[i][j]=<span class="number">101</span>;</span><br><span class="line">            <span class="comment">//别管碰不碰壁，先派个探子去送死,如果探子没事我们就坚持方向，如果有事我们就换方向</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i_try</span> <span class="operator">=</span> i + direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j_try</span> <span class="operator">=</span> j + direction[dir_key][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i_try&lt;<span class="number">0</span> || i_try&gt;=n || j_try&lt;<span class="number">0</span> || j_try&gt;=m || matrix[i_try][j_try]&gt;<span class="number">100</span>)&#123;</span><br><span class="line">                dir_key = (dir_key+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i+direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            j = j+direction[dir_key][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>螺旋矩阵II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">LeetCode原题链接</a></p><h2 id="题目描述-2">题目描述</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="示例1"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[[1,2,3],[8,9,4],[7,6,5]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="解读-2">解读</h2><p>其实本质上和上题是同样的思路，只不过一个是写入，一个是读取，不多赘述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span>[][] way = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">way_key</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*n;i++)&#123;</span><br><span class="line">            res[c][l]=i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + way[way_key][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextl</span> <span class="operator">=</span> l + way[way_key][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span> || nextc &gt;= n || nextl &lt; <span class="number">0</span> || nextl &gt;= n || res[nextc][nextl] != <span class="number">0</span>) &#123;</span><br><span class="line">                way_key = (way_key + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c = c+way[way_key][<span class="number">0</span>];</span><br><span class="line">            l = l+way[way_key][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>螺旋矩阵III</h1><p>这题还有有一点令人难受的，因为需要剪枝才能让效率稍微好一些，但是我剪的也不是非常好</p><p><a href="https://leetcode.cn/problems/spiral-matrix-iii/">LeetCode原题链接</a></p><h2 id="题目描述-3">题目描述</h2><p>在 <code>rows x cols</code> 的网格上，你从单元格 <code>(rStart, cStart)</code> 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 <code>rows x cols</code> 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p><p><strong>示例 1：</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png" alt="示例1"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rows = 1, cols = 4, rStart = 0, cStart = 0</span><br><span class="line">输出：<span class="comment">[<span class="comment">[0,0]</span>,<span class="comment">[0,1]</span>,<span class="comment">[0,2]</span>,<span class="comment">[0,3]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png" alt="示例2"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rows = 5, cols = 6, rStart = 1, cStart = 4</span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,4]</span>,<span class="comment">[1,5]</span>,<span class="comment">[2,5]</span>,<span class="comment">[2,4]</span>,<span class="comment">[2,3]</span>,<span class="comment">[1,3]</span>,<span class="comment">[0,3]</span>,<span class="comment">[0,4]</span>,<span class="comment">[0,5]</span>,<span class="comment">[3,5]</span>,<span class="comment">[3,4]</span>,<span class="comment">[3,3]</span>,<span class="comment">[3,2]</span>,<span class="comment">[2,2]</span>,<span class="comment">[1,2]</span>,<span class="comment">[0,2]</span>,<span class="comment">[4,5]</span>,<span class="comment">[4,4]</span>,<span class="comment">[4,3]</span>,<span class="comment">[4,2]</span>,<span class="comment">[4,1]</span>,<span class="comment">[3,1]</span>,<span class="comment">[2,1]</span>,<span class="comment">[1,1]</span>,<span class="comment">[0,1]</span>,<span class="comment">[4,0]</span>,<span class="comment">[3,0]</span>,<span class="comment">[2,0]</span>,<span class="comment">[1,0]</span>,<span class="comment">[0,0]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= rows, cols &lt;= 100</code></li><li><code>0 &lt;= rStart &lt; rows</code></li><li><code>0 &lt;= cStart &lt; cols</code></li></ul><h2 id="解读-3">解读</h2><p>其实还是老模板，只不过这次不会碰壁，是由内而外，所以需要自己判断螺旋什么时候需要走多少步。</p><p>其实我们可以发现，只要方向由上下变为左右的时候，就需要把螺旋的边长增加1，这点需要自己品味，为什么我设置的初始方向是向上，初始step是0，其实都是有一点意思的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] spiralMatrixIII(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> rStart, <span class="type">int</span> cStart) &#123;</span><br><span class="line">        <span class="type">int</span> r_n=rStart;</span><br><span class="line">        <span class="type">int</span> c_n=cStart;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dir_key</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] res=<span class="keyword">new</span> <span class="title class_">int</span>[rows*cols][<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>]=r_n;</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">1</span>]=c_n;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;rows*cols)&#123;</span><br><span class="line">          <span class="comment">//方向转换</span></span><br><span class="line">            <span class="keyword">if</span>(dir_key%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                step+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dir_key = (dir_key+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">          <span class="comment">//剪枝，如果方向错了，就不用一步一步走了，反正都不会加进去，直接一步走到底</span></span><br><span class="line">            <span class="keyword">if</span>((r_n&lt;<span class="number">0</span>&amp;&amp;direction[dir_key][<span class="number">0</span>]&lt;=<span class="number">0</span>)||</span><br><span class="line">                (c_n&lt;<span class="number">0</span>&amp;&amp;direction[dir_key][<span class="number">1</span>]&lt;=<span class="number">0</span>)||</span><br><span class="line">                (r_n&gt;=rows&amp;&amp;direction[dir_key][<span class="number">0</span>]&gt;=<span class="number">0</span>)||</span><br><span class="line">                (c_n&gt;=cols&amp;&amp;direction[dir_key][<span class="number">1</span>]&gt;=<span class="number">0</span>))&#123;</span><br><span class="line">                r_n=r_n+direction[dir_key][<span class="number">0</span>]*step;</span><br><span class="line">                c_n=c_n+direction[dir_key][<span class="number">1</span>]*step;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 走步</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;step;i++)&#123;</span><br><span class="line">                r_n=r_n+direction[dir_key][<span class="number">0</span>];</span><br><span class="line">                c_n=c_n+direction[dir_key][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r_n&gt;=<span class="number">0</span>&amp;&amp;r_n&lt;rows&amp;&amp;c_n&gt;=<span class="number">0</span>&amp;&amp;c_n&lt;cols)&#123;</span><br><span class="line">                    res[count][<span class="number">0</span>]=r_n;</span><br><span class="line">                    res[count][<span class="number">1</span>]=c_n;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>螺旋矩阵IV</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-iv/">LeetCode原题链接</a></p><h2 id="题目描述-4">题目描述</h2><p>给你两个整数：<code>m</code> 和 <code>n</code> ，表示矩阵的维数。</p><p>另给你一个整数链表的头节点 <code>head</code> 。</p><p>请你生成一个大小为 <code>m x n</code> 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 <strong>左上角</strong> 开始、<strong>顺时针</strong> 按 <strong>螺旋</strong> 顺序填充。如果还存在剩余的空格，则用 <code>-1</code> 填充。</p><p>返回生成的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">5</span>, head = [<span class="number">3,0,2,6</span>,<span class="number">8,1,7,9</span>,<span class="number">4,2,5,5</span>,<span class="number">0</span>]</span><br><span class="line">输出：[[<span class="number">3,0,2,6</span>,<span class="number">8</span>],[<span class="number">5</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>],[<span class="number">5,2,4,9</span>,<span class="number">7</span>]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何排布的。</span><br><span class="line">注意，矩阵中剩下的空格用 -<span class="number">1</span> 填充。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">4</span>, head = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">[[0,1,2,-1]]</span></span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何从左到右排布的。 </span><br><span class="line">注意，矩阵中剩下的空格用 <span class="number">-1</span> 填充。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li>链表中节点数目在范围 <code>[1, m * n]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解读-4">解读</h2><p>这题不多说啊，直接照搬II的代码就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] spiralMatrix(<span class="type">int</span> m, <span class="type">int</span> n, ListNode head) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            Arrays.fill(res[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处定义方向，按序分别为右、下、左、上，也就是我们螺旋的顺序</span></span><br><span class="line">        <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> dir_key=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            res[i][j] = pre.val;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">            <span class="comment">//别管碰不碰壁，先派个探子去送死,如果探子没事我们就坚持方向，如果有事我们就换方向</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i_try</span> <span class="operator">=</span> i + direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j_try</span> <span class="operator">=</span> j + direction[dir_key][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i_try&lt;<span class="number">0</span> || i_try&gt;=m || j_try&lt;<span class="number">0</span> || j_try&gt;=n || res[i_try][j_try]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                dir_key = (dir_key+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i+direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            j = j+direction[dir_key][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于边界处理">关于边界处理</h2><p>其实I和IV都取巧了，就是在判断有没有达到边界的时候，用了数值的范围。</p><p>所以其实墙壁也需要交给我们管理的，所以对于IV的代码，我们也可以这么写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] spiralMatrix(<span class="type">int</span> m, <span class="type">int</span> n, ListNode head) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            Arrays.fill(res[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处定义方向，按序分别为右、下、左、上，也就是我们螺旋的顺序</span></span><br><span class="line">        <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> dir_key=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">      <span class="comment">//初始化边界</span></span><br><span class="line">        <span class="type">int</span> top=<span class="number">0</span>,left=<span class="number">0</span>,bottom=m-<span class="number">1</span>,right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            res[i][j] = pre.val;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">            <span class="comment">//别管碰不碰壁，先派个探子去送死,如果探子没事我们就坚持方向，如果有事我们就换方向</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i_try</span> <span class="operator">=</span> i + direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j_try</span> <span class="operator">=</span> j + direction[dir_key][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i_try&lt;top || i_try&gt;bottom || j_try&lt;left || j_try&gt;right)&#123;</span><br><span class="line">                <span class="comment">//碰壁就缩小墙壁</span></span><br><span class="line">                dir_key = (dir_key+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir_key==<span class="number">0</span>) left+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir_key==<span class="number">1</span>) top+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir_key==<span class="number">2</span>) right-=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir_key==<span class="number">3</span>) bottom-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i+direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            j = j+direction[dir_key][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">如果觉得螺旋矩阵写的不够优雅可以看看这篇，虽然我也写得很一般。</summary>
    
    
    
    <category term="刷题" scheme="https://www.karlyn.xyz/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="Hot100" scheme="https://www.karlyn.xyz/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>IO模式详解</title>
    <link href="https://www.karlyn.xyz/posts/io_introduce.html"/>
    <id>https://www.karlyn.xyz/posts/io_introduce.html</id>
    <published>2025-03-20T06:28:14.000Z</published>
    <updated>2025-03-21T02:01:19.840Z</updated>
    
    <content type="html"><![CDATA[<p><s>我看了B站一堆教程，很少有能把IO多路复用讲明白的，所以我试一试看看能不能讲明白吧。</s></p><p>误！其实还是有的，我这里直接挂个链接！</p><p><a href="https://www.bilibili.com/video/BV1gozdYSEkR">BIO、NIO、IO多路复用</a></p><h1>BIO</h1><p>BIO的概念是同步阻塞IO，两个关键词，同步，阻塞。</p><p>同步在这里主要是看有消息返回之后，是否需要原线程继续处理。</p><p>阻塞是指一个线程在等待某个操作完成时暂停其执行的状态。</p><p>我们以Socket通信的方式来实现这些BIO，以一方请求另一方为例子。</p><p>我们先设计一个Socket的服务端，客户端每次发来消息就让线程休息5s，来模拟执行耗时，5s后给客户端发送一条消息。</p><p>当前我们设计一个客户端，一共进行四次输入，第一次客户端输入不阻塞等带服务器的返回。</p><p>服务端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//定义服务器的接收端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server started on port &quot;</span>+<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();<span class="comment">//阻塞等待客户端连接</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BioHandler</span>(socket)).start(); <span class="comment">// 为每个客户端连接启动新线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BioHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BioHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="built_in">this</span>.socket.getInputStream()));</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="built_in">this</span>.socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                String inputLine;</span><br><span class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 阻塞等待输入</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Received: &quot;</span> + inputLine);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                    <span class="comment">//sleep5s，模拟处理时间</span></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Echo: &quot;</span> + inputLine); <span class="comment">// 回显消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端不阻塞等待返回如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//假设我们固定服务器的端口号为8080，之后我们会访问这个端口号，然后我们会模拟服务器需要很久才会返回</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">//定义发送流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//定义接受流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Connected to server. Type messages and press enter.&quot;</span>);</span><br><span class="line">        String userInput;</span><br><span class="line">        <span class="comment">//我一共进行四次输入，按理来说我这四次输入间隔时间应该是很短的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            userInput = <span class="string">&quot;mess&quot;</span>+i;</span><br><span class="line">            out.println(userInput); <span class="comment">// 发送到服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span>+userInput+<span class="string">&quot;\&quot;已经成功发送，当前时间是&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//描述成功发送到服务器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们看客户端和服务器端分别的时间</p><p>客户端</p><p><img src="/picture/bio_c_nBlock.png" alt="BIO非阻塞客户端"></p><p>服务端</p><p><img src="/picture/bio_s_nBlock.png" alt="BIO非阻塞服务端"></p><p>可以看出，非阻塞的客户端是能直接把全部的消息发给服务器端的，只不过服务器端是一个一个处理的</p><p>那如果我们的客户端阻塞等待服务器端的返回呢？</p><p>只需要在客户端里加上一行代码就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//假设我们固定服务器的端口号为8080，之后我们会访问这个端口号，然后我们会模拟服务器需要很久才会返回</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">//定义发送流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//定义接受流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Connected to server. Type messages and press enter.&quot;</span>);</span><br><span class="line">        String userInput;</span><br><span class="line">        <span class="comment">//我一共进行四次输入，按理来说我这四次输入间隔时间应该是很短的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            userInput = <span class="string">&quot;mess&quot;</span>+i;</span><br><span class="line">            out.println(userInput); <span class="comment">// 发送到服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span>+userInput+<span class="string">&quot;\&quot;已经成功发送，当前时间是&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//描述成功发送到服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;echo: &quot;</span> + in.readLine()); <span class="comment">// 阻塞等待服务器返回消息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这时候客户端的发送的方式是什么呢？</p><p><img src="/picture/bio_c_Block.png" alt="BIO阻塞客户端"></p><p>从结果我们发现，客户端阻塞在这里，等待服务器消费完一条消息才能执行自己接下来要做的事情，如果这时候客户端不是要给服务器发送消息，而是做其他的事情，是不是这些等待时间就是不必要的，完全可以去做其他的事情。</p><p>那么这时候，我们是不是能有这样一种方法，我们不在这里等着服务器处理完，我可以先去做其他的事情，然后时不时看服务器有没有处理完，处理完了我再获取这个数据呢。这时候NIO就应运而生了。</p><h1>NIO</h1><p>NIO的概念是同步非阻塞IO，也就是说我不用阻塞在这里等待对方执行完毕。而是我传递完消息之后就去做我自己的事情，时不时的通过Selector来看一看它是不是有返回值，也就是ReadAble状态。</p><p>所以接下来我们就通过Java来简单实现一下客户端和服务端。</p><p>首先介绍一下Selector，它提供了一种机制来管理多个通道（Channel）的I/O操作。通过使用selector，可以利用一个线程来监视多个通道上的事件（如连接请求、数据到达等），从而实现高效的服务端应用设计，尤其是在处理大量并发连接时。</p><p>我们先来改造客户端吧，改造比较容易，首先是消息就不通过PrintWriter发送了，因为他们属于不同的I/O模型，我们这次就得使用ByteBuffer来存我们的输入数据，然后让Channel去write。</p><p>同时呢，我们需要把Channel注册到Selector上去，让Selector来为我们轮询Channel的状态，当然也未必是轮询，后面我们讲到I/O多路复用的时候会说到。虽然这部分的代码内容稍多一些，但是我的注释写的还是比较翔实的。</p><p>比较有趣的是，这个客户端的实现没有考虑到粘包问题，刚好让我碰到了我以前比较好奇为什么会出现的粘包问题，这部分我们会逐渐优化给大家看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentLinkedQueue&lt;String&gt; messageQueue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        clientChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//将Channel注册到selector中去，并且设置该通道关注可连接事件</span></span><br><span class="line">        clientChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="comment">//当channel没被关的时候一直循环</span></span><br><span class="line">        <span class="keyword">while</span> (clientChannel.isOpen()) &#123;</span><br><span class="line">            <span class="comment">//这段代码还是会阻塞当前线程，直到有注册到selector的通道准备好了进行某项操作</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//一旦 select() 方法返回，通过调用 selectedKeys() 方法来获取一个包含所有已准备好进行操作的通道的 SelectionKey 集合。</span></span><br><span class="line">            <span class="comment">// 每个 SelectionKey 都代表了一个与特定通道和操作相关的键。</span></span><br><span class="line">            <span class="comment">// 这些键包含了关于哪些通道准备好进行哪种类型的操作的信息（例如可读、可写等）。</span></span><br><span class="line">            <span class="comment">// 其实这里包含了多路复用的实现，因为获得了准备好的所有channel的信息，而不是一个channel准备好了就切换回用户态</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">            <span class="comment">//然后对所有准备好的通道依次处理</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="comment">//在第一次channel可用时候，其实只会触发这个isConnectable()，因为我们只注册该通道为可连接的</span></span><br><span class="line">                <span class="comment">//这时候就会调用我们定义好的连接handler</span></span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    handleConnect(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在之后我们关注了可写事件，如果这个通道可写了，selector返回的key里就会设置为可写的</span></span><br><span class="line">                <span class="comment">//这时候就会调用我们定义好的writeHandler</span></span><br><span class="line">                <span class="comment">//可写其实是频繁触发的</span></span><br><span class="line">                <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    handleWrite(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这时候如果服务器返回消息了，就会触发可读事件，selector返回的key里就会设置为可读的</span></span><br><span class="line">                <span class="comment">//这时候就调用我们定义好的readHandler</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    handleRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clientChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key selector的包含channel信息以及其对应类型的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleConnect</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//从key里获取channel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//如果连接完毕，就要把channel的关注切换为关注可写事件</span></span><br><span class="line">        <span class="keyword">if</span> (channel.finishConnect()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接建立成功，开始发送数据...&quot;</span>);</span><br><span class="line">            key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">            <span class="comment">//当然其实也可以这么切换，就是既关注可写事件，又关注可读事件，毕竟谁规定服务器不可以在连接上之后给客户端发消息的</span></span><br><span class="line">            <span class="comment">//key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span></span><br><span class="line">            <span class="comment">//连接成功之后我们往消息队列里加点数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                messageQueue.add(<span class="string">&quot;mess&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//触发可写事件的时候，我们从消息队列里挑选一条消息发过去</span></span><br><span class="line">        <span class="comment">//所以我们可能会触发粘包事件</span></span><br><span class="line">        <span class="keyword">if</span> (!messageQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;触发可写事件且有消息要发！&quot;</span>);</span><br><span class="line">            <span class="comment">//分配写入字节流</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">//从消息队列获取消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> messageQueue.peek();</span><br><span class="line">            <span class="comment">//重置缓冲区，将限制设置为50，并将位置重置为0</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(msg.getBytes());</span><br><span class="line">            <span class="comment">//将缓冲区从写模式切换到读模式。</span></span><br><span class="line">            <span class="comment">//它通过设置限制（limit）为当前位置，并将位置（position）重置为0。</span></span><br><span class="line">            <span class="comment">//这意味着接下来可以从位置0开始读取数据，直到达到之前的位置（现在变成了限制）。</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//向channel写入数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesWritten</span> <span class="operator">=</span> channel.write(buffer);</span><br><span class="line">            <span class="comment">//如果写入数据长度为0，就不进行接下来的操作了，也就是从消息队列里删除，那时候就会重新发送消息</span></span><br><span class="line">            <span class="keyword">if</span> (bytesWritten == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果全部写入成功，就会把消息删除，并且打印已发送</span></span><br><span class="line">            <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sentMsg</span> <span class="operator">=</span> messageQueue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span> + sentMsg + <span class="string">&quot;\&quot;已发送，时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换关注读事件，但保持写事件关注</span></span><br><span class="line">        key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((bytesRead = channel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//同样是把buffer设置为读状态</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//读取响应消息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;收到响应：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, bytesRead)+<span class="string">&quot; ,当前时间是:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了验证读消息之后还能触发写事件，我们每次读完往messageQueue里加2条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count; i &lt; count+<span class="number">2</span>; i++) &#123;</span><br><span class="line">            messageQueue.add(<span class="string">&quot;mess&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        count+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，设计完客户端之后，就是设计服务端了，与之前BIO处理多个连接的方式不同，我们服务端这次不使用多线程来管理多个连接，而是直接使用Selector来管理多个Channel，ServerSocketChannel和SocketChannel一视同仁，都交给一个Selector管理。</p><p>让我们端上来吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// NIO基于Channel控制，所以有Selector管理所有的Channel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 设置监听端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 设置Selector管理所有Channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 注册并设置连接时处理</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功，监听端口为：&quot;</span> + <span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// NIO使用轮询，当有请求连接时，则启动一个线程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">keySelect</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (serverSocketChannel.isOpen()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (next.isAcceptable()) &#123;    <span class="comment">//  如果是连接的</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="keyword">if</span> (accept != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//把新的会话测channel注册到selector里去，让Selector来管理它</span></span><br><span class="line">                        accept.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//并且把它的感兴趣状态变为可读状态</span></span><br><span class="line">                        accept.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//一旦可读了，就代表客户端发来了消息，那我们就去处理这个消息</span></span><br><span class="line">                <span class="keyword">if</span>(next.isReadable())&#123;</span><br><span class="line">                    handleRead(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实处理这个消息我们依然有一处是阻塞的，就是我们返回给客户端的时候，要求客户端是写可用的。</span></span><br><span class="line">    <span class="comment">//但是写可用的触发是很多次的，一般都是写可用的，所以我们就没有做过多的干预</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, read).trim();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端收到消息：&quot;</span>+msg);</span><br><span class="line">        <span class="type">String</span> <span class="variable">outMsg</span> <span class="operator">=</span> <span class="string">&quot;【Echo】&quot;</span> + msg; <span class="comment">// 生成回应信息</span></span><br><span class="line">        <span class="comment">//模拟消息处理时长</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.put(outMsg.getBytes());  <span class="comment">//回传信息放入缓冲区</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);<span class="comment">// 回传信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器的实现我们写的时候还是阻塞的，但是其实写可用触发频率是很高的，所以我们就不把这个阻塞考虑进去了。</p><p>这时候我们起一个服务端，一个客户端看看情况如何！</p><p><img src="/picture/nio_single.png" alt="NIO单客户端"></p><p>是不是出现了粘包问题！在服务器处理mess0（也就是sleep 5s的时候），后面的mess1、mess2、mess3、mess4都到了，但是我们没有使用头部或者区分符号来进行区分，导致出现了粘包问题。</p><p>但是恰恰是这个粘包，也进一步佐证了我们实现了NIO，因为粘包是NIO的常见问题之一。</p><p>那是否我们的服务器在不使用多线程的情况下，不阻塞的同时响应两个客户端呢，我们来试一下就行哩！</p><p><img src="/picture/nio_two.png" alt="NIO多客户端"></p><p>由此可见，是可以的！只不过单线程响应就要做好逐个处理的缓慢准备。</p><h2 id="如何解决粘包问题">如何解决粘包问题</h2><p>其实解决粘包问题很简单，就是设计一个自己通用的协议，比如说设定一个自己通用的终止符号或者设计一个定长的头，用这个头来规定长度。</p><p>我们就选择后者实现。</p><p>下面是服务端的代码，这部分注释就少很多了，主要还是看handleRead部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// NIO基于Channel控制，所以有Selector管理所有的Channel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 设置监听端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 设置Selector管理所有Channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 注册并设置连接时处理</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功，监听端口为：&quot;</span> + <span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// NIO使用轮询，当有请求连接时，则启动一个线程</span></span><br><span class="line">        <span class="keyword">while</span> (serverSocketChannel.isOpen()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (next.isAcceptable()) &#123;    <span class="comment">//  如果是连接的</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="keyword">if</span> (accept != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//把新的会话测channel注册到selector里去，让Selector来管理它</span></span><br><span class="line">                        accept.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//并且把它的感兴趣状态变为可读状态</span></span><br><span class="line">                        accept.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//一旦可读了，就代表客户端发来了消息，那我们就去处理这个消息</span></span><br><span class="line">                <span class="keyword">if</span>(next.isReadable())&#123;</span><br><span class="line">                    handleRead(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span>(read ==-<span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectedLength == -<span class="number">1</span>) &#123; <span class="comment">// 等待读取长度头</span></span><br><span class="line">                <span class="keyword">if</span> (buffer.remaining() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">                    expectedLength = buffer.getInt(); <span class="comment">// 读取4字节长度头</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 长度头未接收完整</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (buffer.remaining() &gt;= expectedLength) &#123;</span><br><span class="line">                <span class="type">byte</span>[] bodyBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[expectedLength];</span><br><span class="line">                buffer.get(bodyBytes);</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bodyBytes);</span><br><span class="line">                System.out.println(<span class="string">&quot;服务端收到消息：&quot;</span>+message);</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;【Echo】&quot;</span> + message;</span><br><span class="line">                <span class="comment">// 模拟处理延迟</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="type">byte</span>[] responseBytes = response.getBytes();</span><br><span class="line">                <span class="comment">// 构造响应：4字节长度头 + 消息体</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">responseBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span> + responseBytes.length);</span><br><span class="line">                responseBuffer.putInt(responseBytes.length);</span><br><span class="line">                responseBuffer.put(responseBytes);</span><br><span class="line">                responseBuffer.flip();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送响应</span></span><br><span class="line">                <span class="keyword">while</span> (responseBuffer.hasRemaining()) &#123;</span><br><span class="line">                    channel.write(responseBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">                expectedLength = -<span class="number">1</span>; <span class="comment">// 重置等待下一个消息</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//消息体未接收完整</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.compact(); <span class="comment">// 压缩缓冲区，保留未处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端部分的代码修改为下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentLinkedQueue&lt;String&gt; messageQueue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        clientChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        clientChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!messageQueue.isEmpty() || clientChannel.isOpen()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    handleConnect(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    handleWrite(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    handleRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clientChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key selector的包含channel信息以及其对应类型的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleConnect</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//从key里获取channel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//如果连接完毕，就要把channel的关注切换为关注可写事件</span></span><br><span class="line">        <span class="keyword">if</span> (channel.finishConnect()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接建立成功，开始发送数据...&quot;</span>);</span><br><span class="line">            key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">            <span class="comment">//当然其实也可以这么切换，就是既关注可写事件，又关注可读事件，毕竟谁规定服务器不可以在连接上之后给客户端发消息的</span></span><br><span class="line">            <span class="comment">//key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span></span><br><span class="line">            <span class="comment">//连接成功之后我们往消息队列里加点数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                messageQueue.add(<span class="string">&quot;mess&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//触发可写事件的时候，我们从消息队列里挑选一条消息发过去</span></span><br><span class="line">        <span class="comment">//所以我们可能会触发粘包事件</span></span><br><span class="line">        <span class="keyword">if</span> (!messageQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;触发可写事件且有消息要发！&quot;</span>);</span><br><span class="line">            <span class="comment">//分配写入字节流</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">//从消息队列获取消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> messageQueue.peek();</span><br><span class="line">            <span class="type">byte</span>[] msgBytes = msg.getBytes();</span><br><span class="line">            <span class="comment">//数据总长为4+真实数据，4是一个int，用来存储数据长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> <span class="number">4</span> + msgBytes.length; <span class="comment">// 头部4字节 + 消息体</span></span><br><span class="line">            <span class="comment">//重置缓冲区，将限制设置为500，并将位置重置为0</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.putInt(msgBytes.length); <span class="comment">// 写入4字节长度头（大端序）</span></span><br><span class="line">            buffer.put(msgBytes);           <span class="comment">// 写入消息体</span></span><br><span class="line">            <span class="comment">//将缓冲区从写模式切换到读模式。</span></span><br><span class="line">            <span class="comment">//它通过设置限制（limit）为当前位置，并将位置（position）重置为0。</span></span><br><span class="line">            <span class="comment">//这意味着接下来可以从位置0开始读取数据，直到达到之前的位置（现在变成了限制）。</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//向channel写入数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesWritten</span> <span class="operator">=</span> channel.write(buffer);</span><br><span class="line">            <span class="comment">//如果写入数据长度为0，就不进行接下来的操作了，也就是从消息队列里删除，那时候就会重新发送消息</span></span><br><span class="line">            <span class="keyword">if</span> (bytesWritten == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果全部写入成功，就会把消息删除，并且打印已发送</span></span><br><span class="line">            <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sentMsg</span> <span class="operator">=</span> messageQueue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span> + sentMsg + <span class="string">&quot;\&quot;已发送，时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> channel.read(readBuffer);</span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedLength</span> <span class="operator">=</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (readBuffer.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectedLength == -<span class="number">1</span>) &#123; <span class="comment">// 等待读取长度头</span></span><br><span class="line">                <span class="keyword">if</span> (readBuffer.remaining() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">                    expectedLength = readBuffer.getInt(); <span class="comment">// 读取4字节长度头</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 长度头未接收完整</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (readBuffer.remaining() &gt;= expectedLength) &#123;</span><br><span class="line">                <span class="type">byte</span>[] bodyBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[expectedLength];</span><br><span class="line">                readBuffer.get(bodyBytes);</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bodyBytes);</span><br><span class="line">                System.out.println(<span class="string">&quot;收到响应：&quot;</span> + response + <span class="string">&quot;，时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                expectedLength = -<span class="number">1</span>; <span class="comment">// 重置等待下一个消息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 消息体未接收完整,继续回去候着</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        readBuffer.compact(); <span class="comment">// 压缩缓冲区，保留未处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的结果如下：</p><p><img src="/picture/nianbao.png" alt="解决NIO粘包问题"></p><p>可以发现，成功解决哩！</p><p>那么接下来，我们就可以转战I/O多路复用了。</p><h1>I/O多路复用</h1><p>其实，在实现之前的NIO的时候，我们已经有用到I/O多路复用了，还记得我们使用了Selector吗，我们把所有的SocketChannel注册到一个Selector上，Selector帮我们判断他们是否能够满足我们关注的事件，如果能满足我们关注的事件，就触发对应的事件关注模式。</p><p>那这时候大家有没有一个疑惑呢？为什么调用<code> Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</code>这段代码，返回的结果是一个集合呢？它监视了select管理的全部channel的状态，这就是IO多路复用的体现！由此，我们在实现NIO的服务器的时候并没有在程序里显示创建额外的子线程来响应，而是创建了一个文件描述符channel，并把它交给selector管理！客户端其实是不需要IO多路复用的，因为客户端只设置了一个Channel。</p><p>想象一下，如果没有IO多路复用，这段代码的逻辑是什么呢？</p><p>我们还是更加具体的讲一下Selector的工作流程吧</p><ol><li><strong>注册通道与兴趣操作</strong>：首先，通过调用<code>SelectableChannel.register(Selector sel, int ops)</code>方法将一个或多个通道注册到选择器上，并指定对该通道感兴趣的I/O操作类型（如<code>OP_READ</code>, <code>OP_WRITE</code>, <code>OP_CONNECT</code>, 或 <code>OP_ACCEPT</code>）。这一步骤主要是在用户态完成的。</li><li><strong>轮询请求</strong>：当调用<code>selector.select()</code>或者其变种时，Java程序会进入等待状态，也就是触发一个打断，由用户态切换到内核态，直到至少有一个已注册的通道准备好执行至少一个你感兴趣的操作。在这个过程中，Java运行时环境会发起系统调用（例如，在Unix/Linux系统上的<code>epoll_wait</code>或在Windows上的<code>WSAWaitForMultipleEvents</code>），这些系统调用实际上会使控制权转移到操作系统内核。</li><li><strong>内核态处理</strong>：一旦控制权转移到内核，操作系统会监视所有被注册的通道，检查它们是否满足任何已注册的兴趣条件。这一过程高效地利用了操作系统提供的事件通知机制，比如Linux上的<code>epoll</code>、BSD系统上的<code>kqueue</code>或Windows上的I/O完成端口(IOCP)等。如果某个或某些通道的状态发生了变化（例如，新的数据到达使得读操作变为可能），内核就会识别出这些事件。</li><li><strong>返回用户态并更新就绪状态</strong>：当有通道变得“就绪”时，操作系统会返回相应的信息给Java的NIO层，然后从<code>select()</code>方法返回，允许Java程序继续执行。此时，你可以通过<code>selectedKeys()</code>方法获取所有已经准备好的通道对应的<code>SelectionKey</code>对象集合，并对这些通道进行相应的I/O操作。</li></ol><p>如果没有IO多路复用呢？是不是处理就不一样了呢？需要手动的遍历每个文件描述符，也就是我们要手动遍历每一个Channel，然后去内核态判断他们是不是可接受、可连接、可读、可写的，然后再回到用户态来进行对应的操作。似乎这样是可行的？</p><p>但是需要注意一点，这样又一个很明显的问题，就是频繁的进行了用户态和内核态的切换，这种切换是需要额外耗时的。</p><p>那么除此之外，其实还有一些其他的问题：</p><ol><li>每个连接都需要一个独立的线程或进程：在这种情况下，为了处理多个并发连接，常见的做法是为每个连接分配一个独立的线程或进程。这个线程或进程将负责执行读写操作，直到该连接关闭。这导致了所谓的“一连接一线程”模型。</li><li>缺乏高效的事件通知机制：在没有IO多路复用（如select、poll、epoll等）的情况下，程序员需要手动检查每个文件描述符的状态，或者依赖于每个线程/进程阻塞在一个特定的文件描述符上等待数据的到来。这种方式无法高效地管理和监控大量文件描述符。</li><li>资源消耗大且扩展性差：由于每个连接都需要一个独立的线程或进程，随着连接数的增加，系统资源（如内存和CPU时间）会被迅速耗尽。此外，大量的上下文切换也会降低系统的整体性能，使得这种方法难以扩展到支持数千甚至数万个并发连接。</li></ol><p>所以这时候我们就可以理解什么是IO多路复用了，简单来说就是：允许单个线程同时监视多个文件描述符。那么具体是怎么实现的，就是下面要讨论的内容了。分为：select、poll、epoll三种。其实到后面已经有点脱离Java的范畴了，所以在这里提前说一下。Java的Selector的select方法是灵活的，主要还是根据系统不同来实现的，如果在Linux内核上，会默认使用epoll来实现，如果epoll有些特性无法满足则会使用poll。在Windows内核上就需要使用select来实现。</p><h2 id="Select">Select</h2><p>Select模型的实现是基于轮询的，也就是每一次都把文件描述符的bitmap从用户态拷贝到内核态。这个bitmap最大大小为1024，所以select模型的一个selector最多只能监管1024个channel</p><p>用户态的bitmap存储了哪些文件描述符需要被监视，如果需要被监视，bitmap对应位置置为1。</p><p>内核态遍历为1的bitmap，如果文件描述符已经就绪，那就将对应位置置为1，否则为0，然后将bitmap返回给用户态</p><p>主要流程如下：</p><ul><li>将当前进程的所有文件描述符，一次性的从用户态拷贝到内核态；</li><li>在内核中快速的无差别遍历每个fd，判断是否有数据到达；</li><li>将所有fd状态，从内核态拷贝到用户态，并返回已就绪fd的个数；</li><li>在用户态遍历判断具体哪个fd已就绪，然后进行相应的事件处理。</li></ul><p>缺点是很明显的：</p><ol><li>能管理的文件描述符有限，最多为1024</li><li>每次都需要将文件描述符的bitmap从用户态拷贝到内核态，再从内核态拷贝到用户态</li><li>内核态返回bitmap之后，用户态仍然需要遍历才能知道哪个文件描述符就绪了</li></ol><p>一共有三个bitmap，分别对应了readfds、writefds、errorfds。主要检查三个对应的项目。</p><p>读缓冲区（readfds）：检测里边有没有数据，如果有数据该缓冲区对应的文件描述符就绪<br>写缓冲区（writefds）：检测写缓冲区是否可以写(有没有容量)，如果有容量可以写，缓冲区对应的文件描述符就绪<br>读写异常（errorfds）：检测读写缓冲区是否有异常，如果有该缓冲区对应的文件描述符就绪</p><h2 id="Poll">Poll</h2><p>Poll模型其实和Select模型是比较类似的，也是需要轮询的。</p><p>区别在于：</p><p>select使用位图来标记想关注的文件描述符，使用三个位图来标记想关注的读事件，写事件，错误事件。</p><p>poll使用一个结构体pollfd数组来标志想关注的文件描述符和在这个描述符上感兴趣的事件，poll的优点是数组的长度突破了1024的限制，其他的区别不大。</p><p>select可以跨平台，但是poll只支持Linux使用</p><p>两者同样都需要进行多次内核态和用户态的拷贝</p><h2 id="EPoll">EPoll</h2><p>其实epoll才是最难理解的部分，但是也是对前两者设计了优化，解决了文件描述符限制和多次内核态和用户态拷贝导致的性能开销问题。</p><p>Epoll其实基于一个比较重要的模型，就是事件驱动模型，使用了回调机制。</p><p>Select模型和Poll模型每次都需要遍历全部的文件描述符来检查它是否就绪，而epoll不同，它允许用户在注册时指定感兴趣的事件，这样在事件发生时，内核只需要更新它的内部数据结构，而不是每次都遍历全部的文件描述符。</p><h3 id="执行原理">执行原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num_size = <span class="number">5</span>;<span class="comment">//epoll监听的文件描述符的个数，其实在linux2.6.8的时候就取消这个限制了，这个数字的存在只是为了兼容</span></span><br><span class="line"><span class="type">int</span> epoll_fd = poll_create(num_size);<span class="comment">//创建一个epoll模型，其实也是一个文件描述符</span></span><br><span class="line"><span class="comment">//然后会创建一个内部数据结构，重点是两个部分，一个是红黑树的根，另一个是rd_list，也就是已就绪的双端队列</span></span><br><span class="line"><span class="comment">//假设这个时候有5个客户端连接到了服务端，epoll就会调用五次event_ctl，会在红黑树上创建5个节点，使用的方法是ADD，如果已经建立完成客户端，就要使用MOD修改监听的事件为读事件</span></span><br><span class="line"><span class="comment">//event_ctl方法需要传入的包括红黑树的根也就是even模型，需要操作的文件描述符，对这个文件描述符的操作，需要监视文件描述符事件集合</span></span><br><span class="line"><span class="comment">//event_ctl方法向内存注册fd和事件的时候，注册了一个回调函数，当操作系统将数据拷贝到缓冲区后，就会执行回调函数</span></span><br><span class="line"><span class="comment">//创建完成之后，如果有三个客户端向服务端的网卡发送数据，网卡会用DMA-Copy技术将数据拷贝到内存缓冲区，执行回调函数，这时候会将缓冲区的内容和文件描述符加入到rd_list，其实没有做拷贝操作，只是做了指针的连接操作</span></span><br><span class="line"><span class="comment">//这时候如果服务端调用epoll_wait方法，就会判断哪些文件描述符上的哪些事件已经就绪了，也就是把rd_link的内容拷贝到返回数组中，然后返回内核态</span></span><br></pre></td></tr></table></figure><h3 id="为什么会快">为什么会快</h3><p>只有被调用epoll_wait方法的时候，epoll才会进行一次内核态到用户态的拷贝，所以上下文切换较少。</p><p>epoll返回的事件只有就绪的事件，不需要遍历比较。</p><p>而且epoll是通过回调的方式来将就绪的事件加入到就绪队列中。</p><h1>总结</h1><p>至此，IO系列基本就分析完了，如果有问题欢迎各种平台交流。</p>]]></content>
    
    
    <summary type="html">设计了一个BIO和NIO的小实验，包含IO设计模式的理解以及NIO的粘包问题复现及解决、I/O多路复用</summary>
    
    
    
    <category term="代码实现" scheme="https://www.karlyn.xyz/categories/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="IO" scheme="https://www.karlyn.xyz/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>BGP整理</title>
    <link href="https://www.karlyn.xyz/posts/bgp_introduce.html"/>
    <id>https://www.karlyn.xyz/posts/bgp_introduce.html</id>
    <published>2025-03-19T01:46:56.000Z</published>
    <updated>2025-03-19T09:38:59.096Z</updated>
    
    <content type="html"><![CDATA[<h1>BGP整理</h1><p>主还是整理一下BGP相关的内容，毕竟有一段在BGP的实习，防止自己逐渐忘记。</p><h2 id="简单介绍">简单介绍</h2><p>BGP也是路由协议之一，主要用在AS间交换路由信息（eBGP），当然也可以用在AS内交换路由信息（iBGP）。</p><p>与其他路由协议利于ISIS、OSPF等建立在IP协议上，RIP建立在UDP上不同，BGP建立在<strong>TCP</strong>连接之上，默认端口号是<strong>179号端口</strong>，所以我们这里有个观念，就是BGP其实是一个应用层的协议，即使它是一个路由协议。</p><p>BGP既然建立在TCP连接之上，就要求BGP对等体之间有稳定的路由链路连接，并不要求对等体之间直接连接。所以BGP所在AS内需要通过ISIS、OSPF、RIP等建立起连接，而通过BGP和其他自治系统通信。</p><p>BGP是基于路径向量的，这既不同于距离向量，也不同于链路状态。BGP所要传递的信息不仅包含到达目的地的最佳路径，还会携带所经过的全部自治系统的AS号，避免路由环路。</p><p>同时，BGP设定了很多属性和策略，可以根据他们来决策不同的最佳路径，包括：本地优先级、多出口区分符(MED)，权重等等。</p><h3 id="常见问题">常见问题</h3><ol><li><p>为什么其他路由不适合做域间路由？</p><p>a. 路由规模问题，IGP主要关注较小的网络环境，没有为处理大量路由信息而优化</p><p>b. 策略控制方面，常见的IGP协议没有提供BGP所提供的诸多策略控制属性，不能对流量进行细粒度控制</p><p>c. 防环方面，一些常用的IGP防环策略（1.最大跳数限制，2.水平分割（接口a收到的路由不会再从接口a广播出去），3.毒性逆转（路由失效的时候并不是直接删除，而是告知邻居自己与其距离无穷大））在跨AS其实并不能很好的使用</p></li><li><p>聊到了IGP的防环策略，那就聊一下BGP的防环策略吧</p><p>a. AS路径过滤，就是当收到的路由更新中包含自己的AS号，就忽略这条路由</p><p>b. IBGP水平分割，iBGP不会把自己从其他iBGP邻居学到的路由转发给另一个iBGP邻居，但是可以转发给他的eBGP邻居</p><p>c. 路由反射器，路由反射器允许一些路由器作为反射器，可以将从一个iBGP邻居学到的路由反射给其他iBGP邻居，解决了需要全连接iBGP才能防环的问题。路由反射器RR会接受与其建立iBGP连接(客户端)以及其他IGP连接(非客户端)的路由器的消息，从从客户端学到的路由反射给客户端和非客户端，从非客户端学到的路由仅反射给客户端。</p><p>路由反射器会在路由更新中添加Originator_ID，记录原始路由器ID，当再次收到相同Originator_ID的路由更新的时候忽略。</p><p>同时如果存在多个路由反射器，每个路由反射器会在Cluster_List里添加自己的Cluster_ID，如果发现自己的ID，就证明集群内循环，直接丢弃</p><p>d. BGP联邦。也就是在AS内划分多个BGP联邦，每个联邦自治，可以使用联邦AS号来避免环路</p></li><li><p>BGP和ISIS的区别</p><p>a. 一个是EGP，一个是IGP</p><p>b. 运行层次，一个运行在TCP的179端口上，一个运行在IP协议之上</p><p>c. 采用的路由算法不同，一个是使用路径向量算法，一个是使用链路状态算法</p><p>d. 适用规模不同，BGP适用于大规模组网，ISIS适合中大企业内部组网</p><p>e. 策略控制力度不同，BGP支持更加细粒度的策略控制</p></li><li><p>BGP和其他协议怎么互相学习</p><p>BGP有IGP路由引入</p></li></ol><h2 id="BGP的属性">BGP的属性</h2><ol><li><p>Origin，路由来源，是通过什么协议学到的，比如IGP，EGP，还是重分布</p></li><li><p>AS_PATH，途经的全部AS号，主要用于防环和根据路径长度选路</p></li><li><p>Next_Hop，下一跳，iBGP一般不会修改下一跳，eBGP会把下一跳修改为本地路由器的接口地址</p></li><li><p>MED，多出口鉴别器，主要是影响其他自治系统如何选择进入本自治系统的路径，较低值优先。仅在两个相邻的AS之内生效。</p></li><li><p>Local_Pref，本地优先级，主要是用于选择怎么离开该自治系统，同样是较低值优先。</p></li><li><p>Community，主要用于路由分组</p></li><li><p>Weight，某些BGP实现商的特有属性，主要用于最佳路径选择</p></li></ol><h3 id="常见问题-2">常见问题</h3><ol><li><p>说到BGP，了解运营商的单线或多线处理吗</p><p>主要是一个网络的ISP接入情况，单线指的是一个网络只使用一条线路或一个ISP截图，简单直接，但是会出现单点故障问题。</p><p>多线处理也被称为BGP多宿主，指的是通过多个ISP接入互联网哪过，通过BGP来管理优化这些连接。</p><p>多个ISP每个需要有独立的AS号，每个ISP之间需要建立eBGP对等体关系，配置出口策略和入口策略等。</p></li></ol><h2 id="BGP邻居建立过程">BGP邻居建立过程</h2><p>输入peer ip as_num as_num指令后一般会接受这些</p><ol><li>建立TCP连接，首先要在两个路由器的179端口号上建立TCP连接，建立成功之后可以初始化BGP对话</li><li>交换Open消息，主要包括双方的AS号，保持时间，BGP标识符（通常是IP地址）</li><li>参数协商，主要是判断Open消息的参数是否正确，正确就进入Established状态</li><li>Established状态要定期发送Keepalive消息来保活</li><li>然后就可以发送Update消息了</li></ol>]]></content>
    
    
    <summary type="html">让我们来回忆一下BGP都有哪些内容吧！</summary>
    
    
    
    <category term="面试" scheme="https://www.karlyn.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="项目介绍" scheme="https://www.karlyn.xyz/tags/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    
    <category term="实习" scheme="https://www.karlyn.xyz/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>项目介绍</title>
    <link href="https://www.karlyn.xyz/posts/project_introduce.html"/>
    <id>https://www.karlyn.xyz/posts/project_introduce.html</id>
    <published>2025-03-18T11:30:44.000Z</published>
    <updated>2025-03-18T12:41:18.737Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="06b561f5d4d4b33d7e56ad635036990402ec2713029d3295d8376cf46cf02a53">a8b0df52fc69ea18510492bd532eeda59897709f31906e07cd42719165d58a20076af797e96049cbf0fe5aa619a8a7514e4254db6a4d13e596f84f3a74c645f47b2b1f93dc2e6f9c413496fe89cb38abd72057ad5fb77fb9902f07d2efd335a9da90ce965cbd987372f08215338effbef10ed5b89fdc9d1f24a9f8b34e65f894648fe975aaed73bb19bddb943fa375c142143525dafeb27eb0e2e9972463e85e6d0ee39177694db6bc005ca4733f995ae09e6ea2a0833fa50aca4ed9f3d912bcf3d52053619b69064bb721870f9812fc87f515a63053cfdac4882f3421eae8fea5f5d033d17ee766631231adc518013b4322e1a3c4e51bedb48d317d899fc4e9df55295e97988e471f487bfb696c557c12671749dbd729ee86c3809d2e428736fed1634938ef836fb367c41cb0dae33612bf27412a032507d223137e59755755f35769dac05c3536bde4254ee8ea645e4429813be4880a4d62850b0bb5f39a4817b3c75b6f762d752aa8f4d3fdc5dc499227c16a551443fa08ef009f320d09eced941a933744b5cc7df1aef46f965bba5742bf57ce9f359eca871093b3e9f8ac068b8fb188507a246baa153caa0d63a3e96cbdb7ceec075e6c9f03b85d1e221bb9d431bbbcad0ae06bea37af4bc519ac5b4055ab3e01384f0962c7e8e6d7b7b02adf5e23d71ea0ac176b72cc568482f3ac053274bd2b7400d70f2c0962f84fd0a848a84dcbf66dba2e533b99cc8f960402756a048be4084bdfd309e94fb893eade6a49b437218253cea067fa230c5092da05d481ce76de989cfcef88201230a8838bf84f6faed999cfd2fe54f9053170f33fd4b2d2a022e031d5c09dfced661cde6d3b2cb904bd1a61568cec82eda4600c15d3940025fab3c9c98e1db8ec667baf9bb5c6d9a43b3159761b5c61f10c5d9059753312c4f867df15fea8ae82da0e91ed974049a43ac298ad53d99e1932057ec66f8511bbc71e99655784aea0f4a98d12666161e8b4c5878defeae55e98533bb125871f8624fe1faba9f8c95481a8282665d081ced3f978ec2de69898ebeabf2b8e490d0c650940a86bb40c9bdbd17d6c06331936283757feebbc2ad0cb7d59335adaac57c5b747bedc2083255a503b1eb1ce258b2f4861054b3ef7fe366ea4fb3d7a02fd431566150fa3e86f9590ed1ff3292f3dadbd1712ae4e8132f896da19b2f22080c4db1db6d85cd278852291616ae4524285bfbb75c55fe93c07bcea3c341a54781c90c6c4af185ad50d54a6b3d57e9695a3e84d4d8f6fd3c6194fdb368d1e4e3f5461bae8036771d32d1bacc212586b27de2e2b3ffe5a0a20c3701389cafa335b6c430c0cae07660636fbca1771fc2f51bebbbdc47f155d62d0ece66ba6e02ad4225b99f53fbaa5ed7a3e1a2d327dba93e486a81f29dee5d3b10d59dbd76e64d88b0fa9dd9d4216f5b9c049b95deb6fc33d5ca65b2cfadbc16b115512e18222769b7e17b734cae42405fc5397ad4aa3121f8d14a1ddf0ea12d6e0f4b68f0fce8b8c9fd1f73d07a2ff5f56fe97e7d3d6f9fcc26d187cc71c72c746fd3b2c5f82980c6e211a096fdda3635762fda9914be1513706f2739eaf3f18821654ffe3728354f2b491cb1a74651e774d628c3834e192aa6358dd6cc64f83fda4fd01c1e8a7bf4320bb552f478750846948a3b63e2b05e548e15dc25f81a822c2cf5c03ebe1ed2f194bd45bc9494771da29adef8efa3f62ed3972c6338a61c4095682a8086082c8d5ff3af820c3d3a18a8c7993bd2f1a056546b72acb214aa2062c807b09fef4458fd0a05c5600d7ec81d561da2348468dd7852ef2c574705ebdffe01afde810950e50ffc152a20ee6cf4d608c4176fb19a75e9546caeb42230dc76de5c33c36b6273a98a63b4188acef6439b460e10ceb5479b86d5d81166c0d882b6b656de7748bb566a9cb0bb030266ed0e1b5209bf98e9d65dab96f350c00ae6743b8b2db923beef6048e1ed59ae69a8e1f58a1b3f54d24fdb5ca6ca679031373ec677134e669f5581bdab23a50fdddf14e094329a9b226075c27afb6e99393476e4705a6c320951da3b8f02f9a6e4157c1ec386f558dc8c0014927765179212e678996826d91c5da98f366d2e91c585247873ac22046260cec4a99ef641c0c5d946172b1eaf29ffa20d3aa8828a23cbd3a98741461b815d392e3343cb2a63ebd6a6e7133a9496c3bd77d640b3cd2d52aa6e9284f7e026b2e7c5d3bce8a200bccaf909137cad2e9aca61b7dc23a438d2141aef837f3a78c7d202dd703c81fc567e1f9504fdd351726d952424d024c9e276ff661a232cfb2a18d6a8a692ccff8cd235eadd61ee6b414c2bb4025c1d391b4bf6a7ec3715a0f3edf4d0027fb6e69ba1c7782be13030888175324c6b3ee0f0264cb3fb89b52c59c0c1a4b38552cacd8e9c89da53ddd799122e36c2f3c66b873e73cb4dac51c8eb209618b5c9e55a80987e5a01313d63e80eb6bd5f5644c5a9b0f0154fa379add8367553c4a590cefc242018bcd290a54de3b68d7435de3e987c8f38fa8463cb18505906b3c270837cf2d309e15632c3bbd3c312fe2ad132f9913e2a87c3aeb4e7dcc091562442e59b2d7f4538780480f646791b1f7b9815a2c03ab9b797d7a71c0742d52fa46d120c71900f96587157e499c807e8f2721cc9a5f4deabc9c943aa8656c177a457bda879a0f952442d53b0553ec64b4f6e84d3d4af8e870d5397adcec8975e941495de566da3f922bf13465d89a9c4d262a2c02a98aff759dc1e6e193ca105f0bf6be7fcd3aeb9c3bcae74842e2456f8d252d475832c2ad1452bd17eef92bcdf3f76ba10fda2df445dff2766e96730d61a660890bb94da3913ee5147604d07f63edfc95206b59449cc0971981247056a649a07f59c147e0b707d7af4c35c960f413a2e1fdb6f4dce3f2b75429bb03388759e68720bb732ee8c35c583f63eb4425ba22a1f7652b108a44d4bdc5e714f5edbe3a6a6a19580150d701a02147be930c61fee97d69ac0d56ec76bec510dbc43717899fad60b3d57ff30e792145e73744b5226c7fdda157575c5a7eaff28a8df503b9f8fb6fbb73d7b44437d4d7b523f74908c26a733e52c8d343699efaa5a082f6c11e470673223deeded2c2976d4246891dd6187c0911409558e35da1b702fd36aa055cdd0dac6d6cffec3679292ec6103b243a5967fd72a3c62dcab75c9cc6b69dd910997cde82e9b62c43f11e115fe6c39287d3fe5448cde1bcedd4ddda0ae9f5db8bdfeefda995253cb20178f642b9c76ecbc5b9ff075de94683f0467133717073c209f6f1656f70afd2729eb696db5ae08110677de1aae201e35f3f1eb0d62332b763077a0e7521c0f676a39e88e94f55cdd8b17b5454f40dbe904569878d0e8a0fc6a2592f53fad5a9b920f82e2cc4c8c14042faa14c91ab225cf9cfdcaa0f21ab76a836e7993b581bfb0f1486deb4e2b626f2d725f90a67e683de741d1d76f8e5677de44390256fac0c97599f7f61b669de5c8efb28236c421c462e3fcbd6c9678bbb7b03a742da0c8d152630ec5f6a5796dd3ad62621fc46a9a760ade2a92c7f1dfa09f2008ed6dee1032fd4748e5d4bd0dff876b604d49da2dad4e7c08790c20507054882c0e404ca98593e9009f2e4efbaeb81b5e911c42e6f57a81aae82dec2ef603cd5440bd0adff218f0edae8da2c7767625660218c05550add7df58aeb9e29ac9f8d2797a9268d5433aae5633d65d6fc73e8d9c495e28014257da569cd776dc1f9e32c5a37f65a9daf669eea34683956f504a067da3512213439a24d6fa17d6ceb5ec1ce0459a9faddc6fe0ab26070c3f38bbd90c3f24192cac625d7da5ae4d58af5f9ad611def0b8ec141ce86bfae2f8b854cc3d9bfad17d5a4d905ffb054035b6184e85ac92ffb527f4ce0d30dbc9c9efede591b2261c6a0d9c7ddff69693516df2ff52d7dcc53ce724ea2fb96f28f76eecf0df8a0aaebad66c11e5f42657d2d3715ea5c5d3fbe49333568505f8f494592865a22aa8c4c42f704b378cbcfb9acbc91790ebcd2cb2f4f1a84868ae1ec838caf0b241f6d72d790f029004bd0476b365c52b55165b5ae736d76a4984a61c5c16a200c3946d67fe83366ac71a0218a1f5369e631b7e105e4000b2c2c89339356c9c60de767d9d561ba4ec327cbb48dd756c0bfa688b82c8ec8be8ff37fab33e0f2f15b08c465a23061e7a6903f856cc5ab1edb20ede41e3e3e57f81ba20c343a338db9ce72a2a2a30936d4b17f9bfe712a93b5af730a01a21b626fb9ecbe4118c1a61de7c47b77dde7982a5052e7c1da77e6483bc3c6df0c3dbb32872cd31925f134c1c0015278b2386eb801787d3d976e1f0dd84cc16c9e91ba8beaa87e575379cfdfebb3c1ac59e6460f73b698c802209c37063151d6b7a39a906c7d3fc2a40ea62f4c8db17fea7fa162f9e24485248ed02d2e36c1004829344b165380abb8d1db27b510956e5dd075cedf3bf0ee106844833f2450a649a0a14610b361131b3dd8789795f6700680d9aa9b5bc9551d5d03889aacaa68ed1335db95312bcdf1f5caa593ca92f159c43c055f82d045f572c431d6da9d8c0477a89734c87037031ce499d8cfbfb7bfbda58c5372ea44a0c7ecf3b041f9b2e1edf76348e9bc11808dfb707b986cb2a1b73201cfd75e746414c3b8e4035b02fde2f127e0c84813f2588fbd1256d695c5ebc66e0881abfbfa8bee6fed56fa1b61367f03bc716bc75b0884b227201dd0db63c576d86bc88215206e851bc82e338a460df66de1469bbb2cb6c8e724a96940bfa86130fb0cd83492acff5c35e6ade8d0be3f0e27d58e486197ee4f0b1ad26f85fc052e9a554175820b80e709ac3854d34b85be2915d254fe437559ac4a4b54c93e3c0b16e4dab97475e84abe2dd13dd09f4ca37a4b014c57a7e662055a78bc2f5908521814aef22430d18df2ac60276fb0ef53cfb80691b6c1b37085b834f8f6b555c398be97054a8ad250e26c23911ace5b231e560ba6a7bd6c2aad821ed6ac4af9bcd7782bda51da4d2007a0a71c6f0cd0fabcce87f62d4843d66b8d47496e9271741414845b075cb0075a226641a36f8390aceb85a943b8ef879e0593f511d2fd0157b81a16a95e72081794f617db65d8ddc183092ecc7d7e0a38f286f0a19e3e7c9929e92e57bd9e8672af6ed01f1f999df5885540e4995ed0617d3b7a3c15bfb9cbf7303b40be4694816abe2fa153f6c39cc348bba98f554eccae2fc1c0d815aafeda9fa005624af14984d3eb3b38d041b3859f6eeb96e7c8da81aa93cfee03fbf504c74ecbe89b1c2e5db74901eab045ac9940d921a9fefc5530e3f6b3983335bf2906aa974645ac23ba93f0b865924fae98ea67a09ce1120c348361563e3af8424fa5c861ecc5af863f3fc4181133202571e3b3aabcad8813e6c1aaece85f23fb0e1aabd08f9c04acfc866c5ba1c70d1c27ea2d2e4e199d14eb83a2891a6c09d8c0e1e41556bb8b4b9a9df16b86fdd71d25e3d205a4a4f098f5434c8c3707555d5c893f4a7d7a55c2fb8c48eabf3c884c0003e57fe53d7c0ec59b93cf2773079d70a24284d5918654ac4d5772e974f5d36bc03286c8a30d081fe85fca7b87056f09023d2d6dae806dc0bf2650e00a68f220f431f249fb5d783b89129579456bcc614a391348b5b5c7968d55db6bcd44ea8c76c941bb6f1dc8ac89dd0b153cd9b1a862f8e64c7da308c5bfb3dd9b82bdb53a9c854fb2f15cfbb3404e5cc38dc274aee3e8dedae5bd7b1bc3f7c9325058ba86d0e8413fb4c3e39ffbc0ba11c3bddc931afb4f6f7ae37a03d7aad12617d0eb21edd08547d426698c5288100b214198ceec2a8729894187a073f6e5195efa38f115a7f0b529277dfad1c8f1712f7dc3e22b9172d84650983a03277571c5a50d4cb75576908dd4956497d30889c4bc2420cc7607ffa8f1f05bbaf796310455834c6edb049633e3aa5679e653e084c29847fe066e3cf80a51a71749e16d25eb50c256361c57a5ffb63a8e5a396907c2ff8f434ed2219c4912bf0ddbb26bab37776e99df1fa9968cba24cf1c71528e6efce2944277780b108710aa0ade77f403b536ce3f347057fa7ee7f6b9f4e43fd9dc33db37662622c2085feec5fbeb8543aded1507c06d0c6f80eae27a68a9468f6b49c3b7b5cf5a4889715be876f601ac7baaf283649a6222aa9c2b913bdb96ea80e2616bfb89514c1e3d64f6751ee45f619c4f3c4d98c5d77247b94a2ced8837e92dd8cbe54f18cb2ef0241f2be3d65331b306056a0c248682b4ca0eaeb37cccd4b3b40d6683895519b3aef415ca4a88d7fea256e77a3f55381166ee307e992bf31c35cee8ff3707294d0eb6f7bc13bf902eb5686f122ab4b699a0dc322e05e379ea9e86b0fa4a805ecd45872c472f96275d8b1507e452f68f86f68f6334489aca445811abc2e41b82a585586d082e3efcd75bd40f7432ee94fe9ea503d6378950dad5c8c60028d36149218c84479f80bc5c806f714e894341c298e2a8d29b442e0c686861c98e7de88e39cb548d834d80f756fd2f28ce9454f5d43eb8d2817d9e5d97f14916d621096e2ffa7b4cab14f553f682d191f61c62b039b91fe4f2e153e1a9f8b34135247fc4811ce74ffe0fb4170b5aa99d1a70577c1d32c3e0374936ef80f2a1a3d782e04c35f620c2e9b72843691fe69530d9ba2d194a3c06fd11d367f7eff7e48240133b537e7e55438ccf51b9559304ac6fee1fc7991908f7d6813a7e711227c93c55396423b9817ef0a218a3628887c68bc9f2b976034b4d98984d042aa4431ceb31f13e12f1dfa020459606be1332b96a6cf3a5aaa0a37842c7a62330e9ca949f2c04e58eb9e5a4b4a1df39af00979c6039d60bef376b47fb1b475859aa93df4b58a49c0580817e8554100c87720d253ebf69c5919869955a06c2dba4da957992fc2ec2e8387e07c8d5aa416f5975e1e0bcfc36f5c188396dfb7c13813225ecffc5717d4eab411645361ad8cbe9229b98e2e683b0597c81c9014febbf94c2da38e56461a4b476f5def2b17bc563553f9143a7c404ba97e4309466b73cc60160eb873b9b50331ec574c212ec94ca02554f35f5bef5d2023a27f129fae2bfc9b287f1063d98e0258dd6bf29d7738264ac08e0f4815d83f4a34d544158975662733913b10302e6af26bb9e94df5404f4d7ec040a341e0f792b60a587be46b45ddf12f64adba4ae1cafaf3d23713cfc5363ce1f9c40b9f12a67ee9f032b6103b01fe541afe709379bd70e213f1cb0918f5249c978a97113ed3ef69a29893d48bc3a2f6d95cccbdadd092475477c26052d31720fee49d5fdbc661cbffb08ca211641ad396f0fb1ed487d1dc44c9dbbb52df652a236ea9fc373c54840a5bb090b505c8fbb306deee971b13e8177eaaef487df755c3f02684804941ca4151e88179711f0e2a4530a7a56fe1de1be460092f37794a2b74b2e9285acddf986bbe758ae1edfd97c58d1b2e04eb7bccc3230d0fb77b541e958a7fc74df2c7071a1a4dc085290227d011ba4df2efcfb6a4f4cd1ce49b194ffe57b5df775165a3ceccbc452b815b0601e73a1b42f2281066216148af315481583a3edd3f159de48b012cf3079c5ae609a3d8a3d2608dfbd42d7f8ec3621128965af753ad4f8a9d6368c921da198c5bdc11f5f7961f73276464d2449d498bd9aa8f1b6b4a31a0168831aa22f0d9aa3c3f9948748012a149ee902ed9089575345d691cf689d77035e0df2089eb878dd4ee3f672c6ca18e534aa73c2d9fdae366b7e774178e36c8b4e5b7bdb137c96386da6ec3e8e968c300f71f2035ef55cebce9e2a0a6c96aa113e12c9cb149d9b30493cd90d45f755e6ee3606c82375eca06ac4419685d5ea94108aa7b4086f4de389cda97e50ee3914272821cda39f80e1463f9fdcc6cda974c6d581cb6213aa5a13e32e164ad5122f12ae83dea6f974a310d614d121f9045ba9b8fe290994427f63e752eb33dcb8b8019325051cd06f1926842a8a5043d85666054a774c63d47c06ed7898b7b337e330b7229f5905dc2028a9654a2c1b6dde521c0df960f6198ad6439ecfe7925f5572e8324788d5d28746fe8a5be7fe4188723178e747f7a6f520d6bcf3b024a7ebb13fa1aaea237ee613ab7c3c53c62c050fcee6b6b6dbf31eeafc53b725afc13d37e8ee8788901e04b3f5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">Hey, password is required here.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">主要是整理一下怎么介绍我的一些项目</summary>
    
    
    
    <category term="面试" scheme="https://www.karlyn.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="项目介绍" scheme="https://www.karlyn.xyz/tags/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>K个一组翻转链表</title>
    <link href="https://www.karlyn.xyz/posts/reverse-nodes-in-k-group.html"/>
    <id>https://www.karlyn.xyz/posts/reverse-nodes-in-k-group.html</id>
    <published>2025-03-18T08:42:03.000Z</published>
    <updated>2025-03-18T08:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1>K个一组翻转链表</h1><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&amp;envId=top-100-liked">LeetCode原题链接</a></p><h2 id="题目描述">题目描述</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="示例1"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="示例2"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p>**进阶：**你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h2 id="题目分析">题目分析</h2><p>这题难度被划归为困难，其实显然是不能达到困难题的难度的，只不过如果不习惯封装编程，单独将反转链表的方法单独写的话可能会有一些边界类型的问题出现。不过提到了需要使用 <code>O(1)</code> 额外内存空间，前置题目为反转链表，题目链接为：<a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">反转链表</a>，只不过反转链表提到可以使用递归或者迭代的方式，但是递归的方式显然需要使用系统栈，无法实现额外内存空间需求，所以这题几乎已经锁定使用迭代的方式进行反转。</p><p>首先我们先尝试做一下反转链表这道题目</p><h3 id="反转链表">反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="示例1"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><p>官方定义的链表结构还是比较简单的，没有要用户自己定义链表，有些企业的面试题是需要自己定义的嘛，所以我们也简单自己定义一下，防患未然了属于是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*定义链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line"><span class="comment">//空参构造方法</span></span><br><span class="line">ListNode()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ListNode(<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="built_in">this</span>.val=val;</span><br><span class="line">&#125;</span><br><span class="line">ListNode(<span class="type">int</span> val,ListNode next)&#123;</span><br><span class="line"><span class="built_in">this</span>.val=val;</span><br><span class="line"><span class="built_in">this</span>.next=next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现任务之前，先简单实现一个输入获取和结果打印的方法，便于本地自行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">readDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    String[] vals = sc.nextLine().replaceAll(<span class="string">&quot;^\\[*|\\]*$&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span>(String val:vals)&#123;</span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(Integer.valueOf(val));</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printListNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> != head)&#123;</span><br><span class="line">        sb.append(head.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是正常实现了，我们分为两种方式实现吧，首先是比较简单的递归的方式实现，递归的方式就是不断把后半段反转然后作为前半段的头部分。</p><p>我的代码可能有一点唐氏，讲得也没有官方的好，所以我贴在这里，简单介绍一下，一些注释基本代表了我的想法，需要注意的只有一点，就是需要先翻转后面的节点，然后再和前面的节点拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表的递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 后面需要反转的链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pre 已经完成反转的前半部分的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转完之后链表的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseListDFS</span><span class="params">(ListNode head,ListNode pre)</span>&#123;</span><br><span class="line">  <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//定义递归终点，也就是最后一个节点，直接把它和它前面的那个节点拼起来然后返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head.next)&#123;</span><br><span class="line">      head.next=pre;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果不是递归终点，这部分就需要理解一下</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//首先是将后面部分翻转！</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> reverseListDFS(head.next, head);</span><br><span class="line">      <span class="comment">//然后将改节点的next改为pre，拼接起来，顺序一定不能错</span></span><br><span class="line">        head.next = pre;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reverseListDFS(head,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让我们来实现一下迭代的方式，迭代主要还是双指针的思路，其实相对而言思路比递归更容易理解一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表迭代实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转完之后链表的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseListIter</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//定义双指针，这个定义是有技巧的，因为头节点的next要是null</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//依次设置前指针的next为后指针</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> != pre)&#123;</span><br><span class="line">        ListNode tmp=pre.next;</span><br><span class="line">        pre.next = lst;</span><br><span class="line">        lst = pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前指针为空时，后指针所指着的位置就是最后一个Node，也就是我们所需要的head</span></span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后反转链表部分我们就基本讲完了，但是迭代这个部分的代码在后面我们还需要进行一点小小的修改，为什么呢，因为K个一组反转链表，链表的终点不是null，而是我们需要的终点是第K个节点。</p><p>接下来就是K个一组反转链表的任务，简单来说，我们只需要把任务拆成K个反转链表的子任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseSubList</span><span class="params">(ListNode head, ListNode last)</span> &#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//定义双指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//依次设置前指针的next为后指针</span></span><br><span class="line">    <span class="keyword">while</span>(last != lst)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        pre.next = lst;</span><br><span class="line">        lst = pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//当k=1的时候，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == k) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//为了统一以及便于找到头，我们定义一个伪头部，其实这是很常用的方法</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fake_head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    fake_head.next=head;</span><br><span class="line">    <span class="comment">//如果k不等于1，接下来我们就需要定义一个节点，这个节点所需要做的事情就是找到每组的第K个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">findK</span> <span class="operator">=</span> fake_head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst_one</span> <span class="operator">=</span> fake_head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里只需要判断findK是不是空，因为它一直走在其余两个交换位置的指针的前面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span>!=findK)&#123;</span><br><span class="line">        <span class="comment">//如果不是第K个，直接后移，不做处理</span></span><br><span class="line">        <span class="keyword">if</span>(count!=k)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            findK=findK.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是第K个</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//重置寻找循环</span></span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//首先是获得子段的头，子段的尾就是findK</span></span><br><span class="line">            ListNode child_head=lst_one.next;</span><br><span class="line">            ListNode K_next=findK.next;</span><br><span class="line">            <span class="comment">//然后进行子段反转，这里会把它的头尾都断开，所以之后就需要重新拼接</span></span><br><span class="line">            reverseSubList(child_head,findK);</span><br><span class="line">            <span class="comment">//然后将前面的子段和尾节点拼接</span></span><br><span class="line">            lst_one.next=findK;</span><br><span class="line">            <span class="comment">//将头节点和后面的节点拼接</span></span><br><span class="line">            child_head.next=K_next;</span><br><span class="line">            <span class="comment">//重置last_one和findK</span></span><br><span class="line">            lst_one = child_head;</span><br><span class="line">            findK = child_head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fake_head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只能说，很优雅，但是还是建议大家看看官解，我写的很简陋。</p>]]></content>
    
    
    <summary type="html">看懂这篇，反转链表系列就都能看懂啦！</summary>
    
    
    
    <category term="刷题" scheme="https://www.karlyn.xyz/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="Hot100" scheme="https://www.karlyn.xyz/tags/Hot100/"/>
    
  </entry>
  
</feed>
