<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhima の blog</title>
  
  
  <link href="https://www.karlyn.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.karlyn.xyz/"/>
  <updated>2025-03-22T14:35:10.543Z</updated>
  <id>https://www.karlyn.xyz/</id>
  
  <author>
    <name>karlyn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>螺旋矩阵汇总</title>
    <link href="https://www.karlyn.xyz/posts/spiral-matrix.html"/>
    <id>https://www.karlyn.xyz/posts/spiral-matrix.html</id>
    <published>2025-03-21T11:15:48.000Z</published>
    <updated>2025-03-22T14:35:10.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>其实螺旋矩阵类的题目按理来说应该是简单的，因为是纯粹的模拟，只不大家定义方向的方式各有不同，以及方向的转换以及判断不够灵活，所以我们就简单试试！</p><h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p><a href="https://leetcode.cn/problems/spiral-matrix/">LeetCode原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="示例1"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[4,5,6]</span>,<span class="comment">[7,8,9]</span>]</span></span><br><span class="line">输出：<span class="comment">[1,2,3,6,9,8,7,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="示例2"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1,2,3,4</span>],[<span class="number">5,6,7,8</span>],[<span class="number">9,10,11,12</span>]]</span><br><span class="line">输出：[<span class="number">1,2,3,4</span>,<span class="number">8,12,11,10</span>,<span class="number">9,5,6,7</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><p>其实这是很经典的顺时针螺旋矩阵了，只需要定义好方向，判断好数组边界以及已访问边界，就可以很顺利解决了。所以接下来我们简单看看实现。</p><p>最重要的事情其实是定义好方向，然后根据方向进行走步。</p><p>学会优雅的第一步，就是勇敢的派出一个探子，让它去尝试，如果它失败了我们就换方向走一步，否则就原方向走一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> m= matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//此处定义方向，按序分别为右、下、左、上，也就是我们螺旋的顺序</span></span><br><span class="line">        <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> dir_key=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; n * m; c++)&#123;</span><br><span class="line">            res.add(matrix[i][j]);</span><br><span class="line">            <span class="comment">//因为有范围为-100，100，标记已经访问过就可以用101</span></span><br><span class="line">            matrix[i][j]=<span class="number">101</span>;</span><br><span class="line">            <span class="comment">//别管碰不碰壁，先派个探子去送死,如果探子没事我们就坚持方向，如果有事我们就换方向</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i_try</span> <span class="operator">=</span> i + direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j_try</span> <span class="operator">=</span> j + direction[dir_key][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i_try&lt;<span class="number">0</span> || i_try&gt;=n || j_try&lt;<span class="number">0</span> || j_try&gt;=m || matrix[i_try][j_try]&gt;<span class="number">100</span>)&#123;</span><br><span class="line">                dir_key = (dir_key+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i+direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            j = j+direction[dir_key][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">LeetCode原题链接</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="示例1"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[[1,2,3],[8,9,4],[7,6,5]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="解读-1"><a href="#解读-1" class="headerlink" title="解读"></a>解读</h2><p>其实本质上和上题是同样的思路，只不过一个是写入，一个是读取，不多赘述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span>[][] way = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">way_key</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*n;i++)&#123;</span><br><span class="line">            res[c][l]=i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + way[way_key][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextl</span> <span class="operator">=</span> l + way[way_key][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span> || nextc &gt;= n || nextl &lt; <span class="number">0</span> || nextl &gt;= n || res[nextc][nextl] != <span class="number">0</span>) &#123;</span><br><span class="line">                way_key = (way_key + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c = c+way[way_key][<span class="number">0</span>];</span><br><span class="line">            l = l+way[way_key][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="螺旋矩阵III"><a href="#螺旋矩阵III" class="headerlink" title="螺旋矩阵III"></a>螺旋矩阵III</h1><p>这题还有有一点令人难受的，因为需要剪枝才能让效率稍微好一些，但是我剪的也不是非常好</p><p><a href="https://leetcode.cn/problems/spiral-matrix-iii/">LeetCode原题链接</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在 <code>rows x cols</code> 的网格上，你从单元格 <code>(rStart, cStart)</code> 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 <code>rows x cols</code> 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p><p><strong>示例 1：</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png" alt="示例1"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rows = 1, cols = 4, rStart = 0, cStart = 0</span><br><span class="line">输出：<span class="comment">[<span class="comment">[0,0]</span>,<span class="comment">[0,1]</span>,<span class="comment">[0,2]</span>,<span class="comment">[0,3]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png" alt="示例2"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rows = 5, cols = 6, rStart = 1, cStart = 4</span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,4]</span>,<span class="comment">[1,5]</span>,<span class="comment">[2,5]</span>,<span class="comment">[2,4]</span>,<span class="comment">[2,3]</span>,<span class="comment">[1,3]</span>,<span class="comment">[0,3]</span>,<span class="comment">[0,4]</span>,<span class="comment">[0,5]</span>,<span class="comment">[3,5]</span>,<span class="comment">[3,4]</span>,<span class="comment">[3,3]</span>,<span class="comment">[3,2]</span>,<span class="comment">[2,2]</span>,<span class="comment">[1,2]</span>,<span class="comment">[0,2]</span>,<span class="comment">[4,5]</span>,<span class="comment">[4,4]</span>,<span class="comment">[4,3]</span>,<span class="comment">[4,2]</span>,<span class="comment">[4,1]</span>,<span class="comment">[3,1]</span>,<span class="comment">[2,1]</span>,<span class="comment">[1,1]</span>,<span class="comment">[0,1]</span>,<span class="comment">[4,0]</span>,<span class="comment">[3,0]</span>,<span class="comment">[2,0]</span>,<span class="comment">[1,0]</span>,<span class="comment">[0,0]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= rows, cols &lt;= 100</code></li><li><code>0 &lt;= rStart &lt; rows</code></li><li><code>0 &lt;= cStart &lt; cols</code></li></ul><h2 id="解读-2"><a href="#解读-2" class="headerlink" title="解读"></a>解读</h2><p>其实还是老模板，只不过这次不会碰壁，是由内而外，所以需要自己判断螺旋什么时候需要走多少步。</p><p>其实我们可以发现，只要方向由上下变为左右的时候，就需要把螺旋的边长增加1，这点需要自己品味，为什么我设置的初始方向是向上，初始step是0，其实都是有一点意思的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] spiralMatrixIII(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> rStart, <span class="type">int</span> cStart) &#123;</span><br><span class="line">        <span class="type">int</span> r_n=rStart;</span><br><span class="line">        <span class="type">int</span> c_n=cStart;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dir_key</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] res=<span class="keyword">new</span> <span class="title class_">int</span>[rows*cols][<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>]=r_n;</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">1</span>]=c_n;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;rows*cols)&#123;</span><br><span class="line">          <span class="comment">//方向转换</span></span><br><span class="line">            <span class="keyword">if</span>(dir_key%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                step+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dir_key = (dir_key+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">          <span class="comment">//剪枝，如果方向错了，就不用一步一步走了，反正都不会加进去，直接一步走到底</span></span><br><span class="line">            <span class="keyword">if</span>((r_n&lt;<span class="number">0</span>&amp;&amp;direction[dir_key][<span class="number">0</span>]&lt;=<span class="number">0</span>)||</span><br><span class="line">                (c_n&lt;<span class="number">0</span>&amp;&amp;direction[dir_key][<span class="number">1</span>]&lt;=<span class="number">0</span>)||</span><br><span class="line">                (r_n&gt;=rows&amp;&amp;direction[dir_key][<span class="number">0</span>]&gt;=<span class="number">0</span>)||</span><br><span class="line">                (c_n&gt;=cols&amp;&amp;direction[dir_key][<span class="number">1</span>]&gt;=<span class="number">0</span>))&#123;</span><br><span class="line">                r_n=r_n+direction[dir_key][<span class="number">0</span>]*step;</span><br><span class="line">                c_n=c_n+direction[dir_key][<span class="number">1</span>]*step;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 走步</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;step;i++)&#123;</span><br><span class="line">                r_n=r_n+direction[dir_key][<span class="number">0</span>];</span><br><span class="line">                c_n=c_n+direction[dir_key][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r_n&gt;=<span class="number">0</span>&amp;&amp;r_n&lt;rows&amp;&amp;c_n&gt;=<span class="number">0</span>&amp;&amp;c_n&lt;cols)&#123;</span><br><span class="line">                    res[count][<span class="number">0</span>]=r_n;</span><br><span class="line">                    res[count][<span class="number">1</span>]=c_n;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="螺旋矩阵IV"><a href="#螺旋矩阵IV" class="headerlink" title="螺旋矩阵IV"></a>螺旋矩阵IV</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-iv/">LeetCode原题链接</a></p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个整数：<code>m</code> 和 <code>n</code> ，表示矩阵的维数。</p><p>另给你一个整数链表的头节点 <code>head</code> 。</p><p>请你生成一个大小为 <code>m x n</code> 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 <strong>左上角</strong> 开始、<strong>顺时针</strong> 按 <strong>螺旋</strong> 顺序填充。如果还存在剩余的空格，则用 <code>-1</code> 填充。</p><p>返回生成的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">5</span>, head = [<span class="number">3,0,2,6</span>,<span class="number">8,1,7,9</span>,<span class="number">4,2,5,5</span>,<span class="number">0</span>]</span><br><span class="line">输出：[[<span class="number">3,0,2,6</span>,<span class="number">8</span>],[<span class="number">5</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>],[<span class="number">5,2,4,9</span>,<span class="number">7</span>]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何排布的。</span><br><span class="line">注意，矩阵中剩下的空格用 -<span class="number">1</span> 填充。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">4</span>, head = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">[[0,1,2,-1]]</span></span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何从左到右排布的。 </span><br><span class="line">注意，矩阵中剩下的空格用 <span class="number">-1</span> 填充。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li>链表中节点数目在范围 <code>[1, m * n]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解读-3"><a href="#解读-3" class="headerlink" title="解读"></a>解读</h2><p>这题不多说啊，直接照搬II的代码就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] spiralMatrix(<span class="type">int</span> m, <span class="type">int</span> n, ListNode head) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            Arrays.fill(res[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处定义方向，按序分别为右、下、左、上，也就是我们螺旋的顺序</span></span><br><span class="line">        <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> dir_key=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            res[i][j] = pre.val;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">            <span class="comment">//别管碰不碰壁，先派个探子去送死,如果探子没事我们就坚持方向，如果有事我们就换方向</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i_try</span> <span class="operator">=</span> i + direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j_try</span> <span class="operator">=</span> j + direction[dir_key][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i_try&lt;<span class="number">0</span> || i_try&gt;=m || j_try&lt;<span class="number">0</span> || j_try&gt;=n || res[i_try][j_try]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                dir_key = (dir_key+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i+direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            j = j+direction[dir_key][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于边界处理"><a href="#关于边界处理" class="headerlink" title="关于边界处理"></a>关于边界处理</h2><p>其实I和IV都取巧了，就是在判断有没有达到边界的时候，用了数值的范围。</p><p>所以其实墙壁也需要交给我们管理的，所以对于IV的代码，我们也可以这么写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] spiralMatrix(<span class="type">int</span> m, <span class="type">int</span> n, ListNode head) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            Arrays.fill(res[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处定义方向，按序分别为右、下、左、上，也就是我们螺旋的顺序</span></span><br><span class="line">        <span class="type">int</span>[][] direction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> dir_key=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">      <span class="comment">//初始化边界</span></span><br><span class="line">        <span class="type">int</span> top=<span class="number">0</span>,left=<span class="number">0</span>,bottom=m-<span class="number">1</span>,right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            res[i][j] = pre.val;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">            <span class="comment">//别管碰不碰壁，先派个探子去送死,如果探子没事我们就坚持方向，如果有事我们就换方向</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i_try</span> <span class="operator">=</span> i + direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j_try</span> <span class="operator">=</span> j + direction[dir_key][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i_try&lt;top || i_try&gt;bottom || j_try&lt;left || j_try&gt;right)&#123;</span><br><span class="line">                <span class="comment">//碰壁就缩小墙壁</span></span><br><span class="line">                dir_key = (dir_key+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir_key==<span class="number">0</span>) left+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir_key==<span class="number">1</span>) top+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir_key==<span class="number">2</span>) right-=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir_key==<span class="number">3</span>) bottom-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i+direction[dir_key][<span class="number">0</span>];</span><br><span class="line">            j = j+direction[dir_key][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">如果觉得螺旋矩阵写的不够优雅可以看看这篇，虽然我也写得很一般。</summary>
    
    
    
    <category term="刷题" scheme="https://www.karlyn.xyz/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="Hot100" scheme="https://www.karlyn.xyz/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>IO模式详解</title>
    <link href="https://www.karlyn.xyz/posts/io_introduce.html"/>
    <id>https://www.karlyn.xyz/posts/io_introduce.html</id>
    <published>2025-03-20T06:28:14.000Z</published>
    <updated>2025-03-21T02:01:19.840Z</updated>
    
    <content type="html"><![CDATA[<p><del>我看了B站一堆教程，很少有能把IO多路复用讲明白的，所以我试一试看看能不能讲明白吧。</del></p><p>误！其实还是有的，我这里直接挂个链接！</p><p><a href="https://www.bilibili.com/video/BV1gozdYSEkR">BIO、NIO、IO多路复用</a></p><h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><p>BIO的概念是同步阻塞IO，两个关键词，同步，阻塞。</p><p>同步在这里主要是看有消息返回之后，是否需要原线程继续处理。</p><p>阻塞是指一个线程在等待某个操作完成时暂停其执行的状态。</p><p>我们以Socket通信的方式来实现这些BIO，以一方请求另一方为例子。</p><p>我们先设计一个Socket的服务端，客户端每次发来消息就让线程休息5s，来模拟执行耗时，5s后给客户端发送一条消息。</p><p>当前我们设计一个客户端，一共进行四次输入，第一次客户端输入不阻塞等带服务器的返回。</p><p>服务端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//定义服务器的接收端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server started on port &quot;</span>+<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();<span class="comment">//阻塞等待客户端连接</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BioHandler</span>(socket)).start(); <span class="comment">// 为每个客户端连接启动新线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BioHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BioHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="built_in">this</span>.socket.getInputStream()));</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="built_in">this</span>.socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                String inputLine;</span><br><span class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 阻塞等待输入</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Received: &quot;</span> + inputLine);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                    <span class="comment">//sleep5s，模拟处理时间</span></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Echo: &quot;</span> + inputLine); <span class="comment">// 回显消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端不阻塞等待返回如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//假设我们固定服务器的端口号为8080，之后我们会访问这个端口号，然后我们会模拟服务器需要很久才会返回</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">//定义发送流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//定义接受流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Connected to server. Type messages and press enter.&quot;</span>);</span><br><span class="line">        String userInput;</span><br><span class="line">        <span class="comment">//我一共进行四次输入，按理来说我这四次输入间隔时间应该是很短的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            userInput = <span class="string">&quot;mess&quot;</span>+i;</span><br><span class="line">            out.println(userInput); <span class="comment">// 发送到服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span>+userInput+<span class="string">&quot;\&quot;已经成功发送，当前时间是&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//描述成功发送到服务器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们看客户端和服务器端分别的时间</p><p>客户端</p><p><img src="/picture/bio_c_nBlock.png" alt="BIO非阻塞客户端"></p><p>服务端</p><p><img src="/picture/bio_s_nBlock.png" alt="BIO非阻塞服务端"></p><p>可以看出，非阻塞的客户端是能直接把全部的消息发给服务器端的，只不过服务器端是一个一个处理的</p><p>那如果我们的客户端阻塞等待服务器端的返回呢？</p><p>只需要在客户端里加上一行代码就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//假设我们固定服务器的端口号为8080，之后我们会访问这个端口号，然后我们会模拟服务器需要很久才会返回</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">//定义发送流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//定义接受流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Connected to server. Type messages and press enter.&quot;</span>);</span><br><span class="line">        String userInput;</span><br><span class="line">        <span class="comment">//我一共进行四次输入，按理来说我这四次输入间隔时间应该是很短的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            userInput = <span class="string">&quot;mess&quot;</span>+i;</span><br><span class="line">            out.println(userInput); <span class="comment">// 发送到服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span>+userInput+<span class="string">&quot;\&quot;已经成功发送，当前时间是&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//描述成功发送到服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;echo: &quot;</span> + in.readLine()); <span class="comment">// 阻塞等待服务器返回消息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这时候客户端的发送的方式是什么呢？</p><p><img src="/picture/bio_c_Block.png" alt="BIO阻塞客户端"></p><p>从结果我们发现，客户端阻塞在这里，等待服务器消费完一条消息才能执行自己接下来要做的事情，如果这时候客户端不是要给服务器发送消息，而是做其他的事情，是不是这些等待时间就是不必要的，完全可以去做其他的事情。</p><p>那么这时候，我们是不是能有这样一种方法，我们不在这里等着服务器处理完，我可以先去做其他的事情，然后时不时看服务器有没有处理完，处理完了我再获取这个数据呢。这时候NIO就应运而生了。</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>NIO的概念是同步非阻塞IO，也就是说我不用阻塞在这里等待对方执行完毕。而是我传递完消息之后就去做我自己的事情，时不时的通过Selector来看一看它是不是有返回值，也就是ReadAble状态。</p><p>所以接下来我们就通过Java来简单实现一下客户端和服务端。</p><p>首先介绍一下Selector，它提供了一种机制来管理多个通道（Channel）的I/O操作。通过使用selector，可以利用一个线程来监视多个通道上的事件（如连接请求、数据到达等），从而实现高效的服务端应用设计，尤其是在处理大量并发连接时。</p><p>我们先来改造客户端吧，改造比较容易，首先是消息就不通过PrintWriter发送了，因为他们属于不同的I/O模型，我们这次就得使用ByteBuffer来存我们的输入数据，然后让Channel去write。</p><p>同时呢，我们需要把Channel注册到Selector上去，让Selector来为我们轮询Channel的状态，当然也未必是轮询，后面我们讲到I/O多路复用的时候会说到。虽然这部分的代码内容稍多一些，但是我的注释写的还是比较翔实的。</p><p>比较有趣的是，这个客户端的实现没有考虑到粘包问题，刚好让我碰到了我以前比较好奇为什么会出现的粘包问题，这部分我们会逐渐优化给大家看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentLinkedQueue&lt;String&gt; messageQueue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        clientChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//将Channel注册到selector中去，并且设置该通道关注可连接事件</span></span><br><span class="line">        clientChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="comment">//当channel没被关的时候一直循环</span></span><br><span class="line">        <span class="keyword">while</span> (clientChannel.isOpen()) &#123;</span><br><span class="line">            <span class="comment">//这段代码还是会阻塞当前线程，直到有注册到selector的通道准备好了进行某项操作</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//一旦 select() 方法返回，通过调用 selectedKeys() 方法来获取一个包含所有已准备好进行操作的通道的 SelectionKey 集合。</span></span><br><span class="line">            <span class="comment">// 每个 SelectionKey 都代表了一个与特定通道和操作相关的键。</span></span><br><span class="line">            <span class="comment">// 这些键包含了关于哪些通道准备好进行哪种类型的操作的信息（例如可读、可写等）。</span></span><br><span class="line">            <span class="comment">// 其实这里包含了多路复用的实现，因为获得了准备好的所有channel的信息，而不是一个channel准备好了就切换回用户态</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">            <span class="comment">//然后对所有准备好的通道依次处理</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="comment">//在第一次channel可用时候，其实只会触发这个isConnectable()，因为我们只注册该通道为可连接的</span></span><br><span class="line">                <span class="comment">//这时候就会调用我们定义好的连接handler</span></span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    handleConnect(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在之后我们关注了可写事件，如果这个通道可写了，selector返回的key里就会设置为可写的</span></span><br><span class="line">                <span class="comment">//这时候就会调用我们定义好的writeHandler</span></span><br><span class="line">                <span class="comment">//可写其实是频繁触发的</span></span><br><span class="line">                <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    handleWrite(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这时候如果服务器返回消息了，就会触发可读事件，selector返回的key里就会设置为可读的</span></span><br><span class="line">                <span class="comment">//这时候就调用我们定义好的readHandler</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    handleRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clientChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key selector的包含channel信息以及其对应类型的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleConnect</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//从key里获取channel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//如果连接完毕，就要把channel的关注切换为关注可写事件</span></span><br><span class="line">        <span class="keyword">if</span> (channel.finishConnect()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接建立成功，开始发送数据...&quot;</span>);</span><br><span class="line">            key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">            <span class="comment">//当然其实也可以这么切换，就是既关注可写事件，又关注可读事件，毕竟谁规定服务器不可以在连接上之后给客户端发消息的</span></span><br><span class="line">            <span class="comment">//key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span></span><br><span class="line">            <span class="comment">//连接成功之后我们往消息队列里加点数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                messageQueue.add(<span class="string">&quot;mess&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//触发可写事件的时候，我们从消息队列里挑选一条消息发过去</span></span><br><span class="line">        <span class="comment">//所以我们可能会触发粘包事件</span></span><br><span class="line">        <span class="keyword">if</span> (!messageQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;触发可写事件且有消息要发！&quot;</span>);</span><br><span class="line">            <span class="comment">//分配写入字节流</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">//从消息队列获取消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> messageQueue.peek();</span><br><span class="line">            <span class="comment">//重置缓冲区，将限制设置为50，并将位置重置为0</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(msg.getBytes());</span><br><span class="line">            <span class="comment">//将缓冲区从写模式切换到读模式。</span></span><br><span class="line">            <span class="comment">//它通过设置限制（limit）为当前位置，并将位置（position）重置为0。</span></span><br><span class="line">            <span class="comment">//这意味着接下来可以从位置0开始读取数据，直到达到之前的位置（现在变成了限制）。</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//向channel写入数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesWritten</span> <span class="operator">=</span> channel.write(buffer);</span><br><span class="line">            <span class="comment">//如果写入数据长度为0，就不进行接下来的操作了，也就是从消息队列里删除，那时候就会重新发送消息</span></span><br><span class="line">            <span class="keyword">if</span> (bytesWritten == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果全部写入成功，就会把消息删除，并且打印已发送</span></span><br><span class="line">            <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sentMsg</span> <span class="operator">=</span> messageQueue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span> + sentMsg + <span class="string">&quot;\&quot;已发送，时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换关注读事件，但保持写事件关注</span></span><br><span class="line">        key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((bytesRead = channel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//同样是把buffer设置为读状态</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//读取响应消息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;收到响应：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, bytesRead)+<span class="string">&quot; ,当前时间是:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了验证读消息之后还能触发写事件，我们每次读完往messageQueue里加2条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count; i &lt; count+<span class="number">2</span>; i++) &#123;</span><br><span class="line">            messageQueue.add(<span class="string">&quot;mess&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        count+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，设计完客户端之后，就是设计服务端了，与之前BIO处理多个连接的方式不同，我们服务端这次不使用多线程来管理多个连接，而是直接使用Selector来管理多个Channel，ServerSocketChannel和SocketChannel一视同仁，都交给一个Selector管理。</p><p>让我们端上来吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// NIO基于Channel控制，所以有Selector管理所有的Channel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 设置监听端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 设置Selector管理所有Channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 注册并设置连接时处理</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功，监听端口为：&quot;</span> + <span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// NIO使用轮询，当有请求连接时，则启动一个线程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">keySelect</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (serverSocketChannel.isOpen()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (next.isAcceptable()) &#123;    <span class="comment">//  如果是连接的</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="keyword">if</span> (accept != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//把新的会话测channel注册到selector里去，让Selector来管理它</span></span><br><span class="line">                        accept.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//并且把它的感兴趣状态变为可读状态</span></span><br><span class="line">                        accept.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//一旦可读了，就代表客户端发来了消息，那我们就去处理这个消息</span></span><br><span class="line">                <span class="keyword">if</span>(next.isReadable())&#123;</span><br><span class="line">                    handleRead(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实处理这个消息我们依然有一处是阻塞的，就是我们返回给客户端的时候，要求客户端是写可用的。</span></span><br><span class="line">    <span class="comment">//但是写可用的触发是很多次的，一般都是写可用的，所以我们就没有做过多的干预</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, read).trim();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端收到消息：&quot;</span>+msg);</span><br><span class="line">        <span class="type">String</span> <span class="variable">outMsg</span> <span class="operator">=</span> <span class="string">&quot;【Echo】&quot;</span> + msg; <span class="comment">// 生成回应信息</span></span><br><span class="line">        <span class="comment">//模拟消息处理时长</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.put(outMsg.getBytes());  <span class="comment">//回传信息放入缓冲区</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);<span class="comment">// 回传信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器的实现我们写的时候还是阻塞的，但是其实写可用触发频率是很高的，所以我们就不把这个阻塞考虑进去了。</p><p>这时候我们起一个服务端，一个客户端看看情况如何！</p><p><img src="/picture/nio_single.png" alt="NIO单客户端"></p><p>是不是出现了粘包问题！在服务器处理mess0（也就是sleep 5s的时候），后面的mess1、mess2、mess3、mess4都到了，但是我们没有使用头部或者区分符号来进行区分，导致出现了粘包问题。</p><p>但是恰恰是这个粘包，也进一步佐证了我们实现了NIO，因为粘包是NIO的常见问题之一。</p><p>那是否我们的服务器在不使用多线程的情况下，不阻塞的同时响应两个客户端呢，我们来试一下就行哩！</p><p><img src="/picture/nio_two.png" alt="NIO多客户端"></p><p>由此可见，是可以的！只不过单线程响应就要做好逐个处理的缓慢准备。</p><h2 id="如何解决粘包问题"><a href="#如何解决粘包问题" class="headerlink" title="如何解决粘包问题"></a>如何解决粘包问题</h2><p>其实解决粘包问题很简单，就是设计一个自己通用的协议，比如说设定一个自己通用的终止符号或者设计一个定长的头，用这个头来规定长度。</p><p>我们就选择后者实现。</p><p>下面是服务端的代码，这部分注释就少很多了，主要还是看handleRead部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// NIO基于Channel控制，所以有Selector管理所有的Channel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 设置监听端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 设置Selector管理所有Channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 注册并设置连接时处理</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功，监听端口为：&quot;</span> + <span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// NIO使用轮询，当有请求连接时，则启动一个线程</span></span><br><span class="line">        <span class="keyword">while</span> (serverSocketChannel.isOpen()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (next.isAcceptable()) &#123;    <span class="comment">//  如果是连接的</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="keyword">if</span> (accept != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//把新的会话测channel注册到selector里去，让Selector来管理它</span></span><br><span class="line">                        accept.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//并且把它的感兴趣状态变为可读状态</span></span><br><span class="line">                        accept.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//一旦可读了，就代表客户端发来了消息，那我们就去处理这个消息</span></span><br><span class="line">                <span class="keyword">if</span>(next.isReadable())&#123;</span><br><span class="line">                    handleRead(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span>(read ==-<span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectedLength == -<span class="number">1</span>) &#123; <span class="comment">// 等待读取长度头</span></span><br><span class="line">                <span class="keyword">if</span> (buffer.remaining() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">                    expectedLength = buffer.getInt(); <span class="comment">// 读取4字节长度头</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 长度头未接收完整</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (buffer.remaining() &gt;= expectedLength) &#123;</span><br><span class="line">                <span class="type">byte</span>[] bodyBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[expectedLength];</span><br><span class="line">                buffer.get(bodyBytes);</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bodyBytes);</span><br><span class="line">                System.out.println(<span class="string">&quot;服务端收到消息：&quot;</span>+message);</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;【Echo】&quot;</span> + message;</span><br><span class="line">                <span class="comment">// 模拟处理延迟</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="type">byte</span>[] responseBytes = response.getBytes();</span><br><span class="line">                <span class="comment">// 构造响应：4字节长度头 + 消息体</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">responseBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span> + responseBytes.length);</span><br><span class="line">                responseBuffer.putInt(responseBytes.length);</span><br><span class="line">                responseBuffer.put(responseBytes);</span><br><span class="line">                responseBuffer.flip();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送响应</span></span><br><span class="line">                <span class="keyword">while</span> (responseBuffer.hasRemaining()) &#123;</span><br><span class="line">                    channel.write(responseBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">                expectedLength = -<span class="number">1</span>; <span class="comment">// 重置等待下一个消息</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//消息体未接收完整</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.compact(); <span class="comment">// 压缩缓冲区，保留未处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端部分的代码修改为下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentLinkedQueue&lt;String&gt; messageQueue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        clientChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        clientChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!messageQueue.isEmpty() || clientChannel.isOpen()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    handleConnect(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    handleWrite(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    handleRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clientChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key selector的包含channel信息以及其对应类型的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleConnect</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//从key里获取channel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//如果连接完毕，就要把channel的关注切换为关注可写事件</span></span><br><span class="line">        <span class="keyword">if</span> (channel.finishConnect()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接建立成功，开始发送数据...&quot;</span>);</span><br><span class="line">            key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">            <span class="comment">//当然其实也可以这么切换，就是既关注可写事件，又关注可读事件，毕竟谁规定服务器不可以在连接上之后给客户端发消息的</span></span><br><span class="line">            <span class="comment">//key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span></span><br><span class="line">            <span class="comment">//连接成功之后我们往消息队列里加点数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                messageQueue.add(<span class="string">&quot;mess&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="comment">//触发可写事件的时候，我们从消息队列里挑选一条消息发过去</span></span><br><span class="line">        <span class="comment">//所以我们可能会触发粘包事件</span></span><br><span class="line">        <span class="keyword">if</span> (!messageQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;触发可写事件且有消息要发！&quot;</span>);</span><br><span class="line">            <span class="comment">//分配写入字节流</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">//从消息队列获取消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> messageQueue.peek();</span><br><span class="line">            <span class="type">byte</span>[] msgBytes = msg.getBytes();</span><br><span class="line">            <span class="comment">//数据总长为4+真实数据，4是一个int，用来存储数据长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> <span class="number">4</span> + msgBytes.length; <span class="comment">// 头部4字节 + 消息体</span></span><br><span class="line">            <span class="comment">//重置缓冲区，将限制设置为500，并将位置重置为0</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.putInt(msgBytes.length); <span class="comment">// 写入4字节长度头（大端序）</span></span><br><span class="line">            buffer.put(msgBytes);           <span class="comment">// 写入消息体</span></span><br><span class="line">            <span class="comment">//将缓冲区从写模式切换到读模式。</span></span><br><span class="line">            <span class="comment">//它通过设置限制（limit）为当前位置，并将位置（position）重置为0。</span></span><br><span class="line">            <span class="comment">//这意味着接下来可以从位置0开始读取数据，直到达到之前的位置（现在变成了限制）。</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//向channel写入数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesWritten</span> <span class="operator">=</span> channel.write(buffer);</span><br><span class="line">            <span class="comment">//如果写入数据长度为0，就不进行接下来的操作了，也就是从消息队列里删除，那时候就会重新发送消息</span></span><br><span class="line">            <span class="keyword">if</span> (bytesWritten == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果全部写入成功，就会把消息删除，并且打印已发送</span></span><br><span class="line">            <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sentMsg</span> <span class="operator">=</span> messageQueue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消息:\&quot;&quot;</span> + sentMsg + <span class="string">&quot;\&quot;已发送，时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> channel.read(readBuffer);</span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedLength</span> <span class="operator">=</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (readBuffer.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectedLength == -<span class="number">1</span>) &#123; <span class="comment">// 等待读取长度头</span></span><br><span class="line">                <span class="keyword">if</span> (readBuffer.remaining() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">                    expectedLength = readBuffer.getInt(); <span class="comment">// 读取4字节长度头</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 长度头未接收完整</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (readBuffer.remaining() &gt;= expectedLength) &#123;</span><br><span class="line">                <span class="type">byte</span>[] bodyBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[expectedLength];</span><br><span class="line">                readBuffer.get(bodyBytes);</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bodyBytes);</span><br><span class="line">                System.out.println(<span class="string">&quot;收到响应：&quot;</span> + response + <span class="string">&quot;，时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                expectedLength = -<span class="number">1</span>; <span class="comment">// 重置等待下一个消息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 消息体未接收完整,继续回去候着</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        readBuffer.compact(); <span class="comment">// 压缩缓冲区，保留未处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的结果如下：</p><p><img src="/picture/nianbao.png" alt="解决NIO粘包问题"></p><p>可以发现，成功解决哩！</p><p>那么接下来，我们就可以转战I/O多路复用了。</p><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>其实，在实现之前的NIO的时候，我们已经有用到I/O多路复用了，还记得我们使用了Selector吗，我们把所有的SocketChannel注册到一个Selector上，Selector帮我们判断他们是否能够满足我们关注的事件，如果能满足我们关注的事件，就触发对应的事件关注模式。</p><p>那这时候大家有没有一个疑惑呢？为什么调用<code>Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</code>这段代码，返回的结果是一个集合呢？它监视了select管理的全部channel的状态，这就是IO多路复用的体现！由此，我们在实现NIO的服务器的时候并没有在程序里显示创建额外的子线程来响应，而是创建了一个文件描述符channel，并把它交给selector管理！客户端其实是不需要IO多路复用的，因为客户端只设置了一个Channel。</p><p>想象一下，如果没有IO多路复用，这段代码的逻辑是什么呢？</p><p>我们还是更加具体的讲一下Selector的工作流程吧</p><ol><li><strong>注册通道与兴趣操作</strong>：首先，通过调用<code>SelectableChannel.register(Selector sel, int ops)</code>方法将一个或多个通道注册到选择器上，并指定对该通道感兴趣的I/O操作类型（如<code>OP_READ</code>, <code>OP_WRITE</code>, <code>OP_CONNECT</code>, 或 <code>OP_ACCEPT</code>）。这一步骤主要是在用户态完成的。</li><li><strong>轮询请求</strong>：当调用<code>selector.select()</code>或者其变种时，Java程序会进入等待状态，也就是触发一个打断，由用户态切换到内核态，直到至少有一个已注册的通道准备好执行至少一个你感兴趣的操作。在这个过程中，Java运行时环境会发起系统调用（例如，在Unix/Linux系统上的<code>epoll_wait</code>或在Windows上的<code>WSAWaitForMultipleEvents</code>），这些系统调用实际上会使控制权转移到操作系统内核。</li><li><strong>内核态处理</strong>：一旦控制权转移到内核，操作系统会监视所有被注册的通道，检查它们是否满足任何已注册的兴趣条件。这一过程高效地利用了操作系统提供的事件通知机制，比如Linux上的<code>epoll</code>、BSD系统上的<code>kqueue</code>或Windows上的I/O完成端口(IOCP)等。如果某个或某些通道的状态发生了变化（例如，新的数据到达使得读操作变为可能），内核就会识别出这些事件。</li><li><strong>返回用户态并更新就绪状态</strong>：当有通道变得“就绪”时，操作系统会返回相应的信息给Java的NIO层，然后从<code>select()</code>方法返回，允许Java程序继续执行。此时，你可以通过<code>selectedKeys()</code>方法获取所有已经准备好的通道对应的<code>SelectionKey</code>对象集合，并对这些通道进行相应的I/O操作。</li></ol><p>如果没有IO多路复用呢？是不是处理就不一样了呢？需要手动的遍历每个文件描述符，也就是我们要手动遍历每一个Channel，然后去内核态判断他们是不是可接受、可连接、可读、可写的，然后再回到用户态来进行对应的操作。似乎这样是可行的？</p><p>但是需要注意一点，这样又一个很明显的问题，就是频繁的进行了用户态和内核态的切换，这种切换是需要额外耗时的。</p><p>那么除此之外，其实还有一些其他的问题：</p><ol><li>每个连接都需要一个独立的线程或进程：在这种情况下，为了处理多个并发连接，常见的做法是为每个连接分配一个独立的线程或进程。这个线程或进程将负责执行读写操作，直到该连接关闭。这导致了所谓的“一连接一线程”模型。</li><li>缺乏高效的事件通知机制：在没有IO多路复用（如select、poll、epoll等）的情况下，程序员需要手动检查每个文件描述符的状态，或者依赖于每个线程/进程阻塞在一个特定的文件描述符上等待数据的到来。这种方式无法高效地管理和监控大量文件描述符。</li><li>资源消耗大且扩展性差：由于每个连接都需要一个独立的线程或进程，随着连接数的增加，系统资源（如内存和CPU时间）会被迅速耗尽。此外，大量的上下文切换也会降低系统的整体性能，使得这种方法难以扩展到支持数千甚至数万个并发连接。</li></ol><p>所以这时候我们就可以理解什么是IO多路复用了，简单来说就是：允许单个线程同时监视多个文件描述符。那么具体是怎么实现的，就是下面要讨论的内容了。分为：select、poll、epoll三种。其实到后面已经有点脱离Java的范畴了，所以在这里提前说一下。Java的Selector的select方法是灵活的，主要还是根据系统不同来实现的，如果在Linux内核上，会默认使用epoll来实现，如果epoll有些特性无法满足则会使用poll。在Windows内核上就需要使用select来实现。</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>Select模型的实现是基于轮询的，也就是每一次都把文件描述符的bitmap从用户态拷贝到内核态。这个bitmap最大大小为1024，所以select模型的一个selector最多只能监管1024个channel</p><p>用户态的bitmap存储了哪些文件描述符需要被监视，如果需要被监视，bitmap对应位置置为1。</p><p>内核态遍历为1的bitmap，如果文件描述符已经就绪，那就将对应位置置为1，否则为0，然后将bitmap返回给用户态</p><p>主要流程如下：</p><ul><li>将当前进程的所有文件描述符，一次性的从用户态拷贝到内核态；</li><li>在内核中快速的无差别遍历每个fd，判断是否有数据到达；</li><li>将所有fd状态，从内核态拷贝到用户态，并返回已就绪fd的个数；</li><li>在用户态遍历判断具体哪个fd已就绪，然后进行相应的事件处理。</li></ul><p>缺点是很明显的：</p><ol><li>能管理的文件描述符有限，最多为1024</li><li>每次都需要将文件描述符的bitmap从用户态拷贝到内核态，再从内核态拷贝到用户态</li><li>内核态返回bitmap之后，用户态仍然需要遍历才能知道哪个文件描述符就绪了</li></ol><p>一共有三个bitmap，分别对应了readfds、writefds、errorfds。主要检查三个对应的项目。</p><p>读缓冲区（readfds）：检测里边有没有数据，如果有数据该缓冲区对应的文件描述符就绪<br>写缓冲区（writefds）：检测写缓冲区是否可以写(有没有容量)，如果有容量可以写，缓冲区对应的文件描述符就绪<br>读写异常（errorfds）：检测读写缓冲区是否有异常，如果有该缓冲区对应的文件描述符就绪</p><h2 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h2><p>Poll模型其实和Select模型是比较类似的，也是需要轮询的。</p><p>区别在于：</p><p>select使用位图来标记想关注的文件描述符，使用三个位图来标记想关注的读事件，写事件，错误事件。</p><p>poll使用一个结构体pollfd数组来标志想关注的文件描述符和在这个描述符上感兴趣的事件，poll的优点是数组的长度突破了1024的限制，其他的区别不大。</p><p>select可以跨平台，但是poll只支持Linux使用</p><p>两者同样都需要进行多次内核态和用户态的拷贝</p><h2 id="EPoll"><a href="#EPoll" class="headerlink" title="EPoll"></a>EPoll</h2><p>其实epoll才是最难理解的部分，但是也是对前两者设计了优化，解决了文件描述符限制和多次内核态和用户态拷贝导致的性能开销问题。</p><p>Epoll其实基于一个比较重要的模型，就是事件驱动模型，使用了回调机制。</p><p>Select模型和Poll模型每次都需要遍历全部的文件描述符来检查它是否就绪，而epoll不同，它允许用户在注册时指定感兴趣的事件，这样在事件发生时，内核只需要更新它的内部数据结构，而不是每次都遍历全部的文件描述符。</p><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num_size = <span class="number">5</span>;<span class="comment">//epoll监听的文件描述符的个数，其实在linux2.6.8的时候就取消这个限制了，这个数字的存在只是为了兼容</span></span><br><span class="line"><span class="type">int</span> epoll_fd = poll_create(num_size);<span class="comment">//创建一个epoll模型，其实也是一个文件描述符</span></span><br><span class="line"><span class="comment">//然后会创建一个内部数据结构，重点是两个部分，一个是红黑树的根，另一个是rd_list，也就是已就绪的双端队列</span></span><br><span class="line"><span class="comment">//假设这个时候有5个客户端连接到了服务端，epoll就会调用五次event_ctl，会在红黑树上创建5个节点，使用的方法是ADD，如果已经建立完成客户端，就要使用MOD修改监听的事件为读事件</span></span><br><span class="line"><span class="comment">//event_ctl方法需要传入的包括红黑树的根也就是even模型，需要操作的文件描述符，对这个文件描述符的操作，需要监视文件描述符事件集合</span></span><br><span class="line"><span class="comment">//event_ctl方法向内存注册fd和事件的时候，注册了一个回调函数，当操作系统将数据拷贝到缓冲区后，就会执行回调函数</span></span><br><span class="line"><span class="comment">//创建完成之后，如果有三个客户端向服务端的网卡发送数据，网卡会用DMA-Copy技术将数据拷贝到内存缓冲区，执行回调函数，这时候会将缓冲区的内容和文件描述符加入到rd_list，其实没有做拷贝操作，只是做了指针的连接操作</span></span><br><span class="line"><span class="comment">//这时候如果服务端调用epoll_wait方法，就会判断哪些文件描述符上的哪些事件已经就绪了，也就是把rd_link的内容拷贝到返回数组中，然后返回内核态</span></span><br></pre></td></tr></table></figure><h3 id="为什么会快"><a href="#为什么会快" class="headerlink" title="为什么会快"></a>为什么会快</h3><p>只有被调用epoll_wait方法的时候，epoll才会进行一次内核态到用户态的拷贝，所以上下文切换较少。</p><p>epoll返回的事件只有就绪的事件，不需要遍历比较。</p><p>而且epoll是通过回调的方式来将就绪的事件加入到就绪队列中。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，IO系列基本就分析完了，如果有问题欢迎各种平台交流。</p>]]></content>
    
    
    <summary type="html">设计了一个BIO和NIO的小实验，包含IO设计模式的理解以及NIO的粘包问题复现及解决、I/O多路复用</summary>
    
    
    
    <category term="代码实现" scheme="https://www.karlyn.xyz/categories/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="IO" scheme="https://www.karlyn.xyz/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>BGP整理</title>
    <link href="https://www.karlyn.xyz/posts/bgp_introduce.html"/>
    <id>https://www.karlyn.xyz/posts/bgp_introduce.html</id>
    <published>2025-03-19T01:46:56.000Z</published>
    <updated>2025-03-19T09:38:59.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BGP整理"><a href="#BGP整理" class="headerlink" title="BGP整理"></a>BGP整理</h1><p>主还是整理一下BGP相关的内容，毕竟有一段在BGP的实习，防止自己逐渐忘记。</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>BGP也是路由协议之一，主要用在AS间交换路由信息（eBGP），当然也可以用在AS内交换路由信息（iBGP）。</p><p>与其他路由协议利于ISIS、OSPF等建立在IP协议上，RIP建立在UDP上不同，BGP建立在<strong>TCP</strong>连接之上，默认端口号是<strong>179号端口</strong>，所以我们这里有个观念，就是BGP其实是一个应用层的协议，即使它是一个路由协议。</p><p>BGP既然建立在TCP连接之上，就要求BGP对等体之间有稳定的路由链路连接，并不要求对等体之间直接连接。所以BGP所在AS内需要通过ISIS、OSPF、RIP等建立起连接，而通过BGP和其他自治系统通信。</p><p>BGP是基于路径向量的，这既不同于距离向量，也不同于链路状态。BGP所要传递的信息不仅包含到达目的地的最佳路径，还会携带所经过的全部自治系统的AS号，避免路由环路。</p><p>同时，BGP设定了很多属性和策略，可以根据他们来决策不同的最佳路径，包括：本地优先级、多出口区分符(MED)，权重等等。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li><p>为什么其他路由不适合做域间路由？</p><p>a. 路由规模问题，IGP主要关注较小的网络环境，没有为处理大量路由信息而优化</p><p>b. 策略控制方面，常见的IGP协议没有提供BGP所提供的诸多策略控制属性，不能对流量进行细粒度控制</p><p>c. 防环方面，一些常用的IGP防环策略（1.最大跳数限制，2.水平分割（接口a收到的路由不会再从接口a广播出去），3.毒性逆转（路由失效的时候并不是直接删除，而是告知邻居自己与其距离无穷大））在跨AS其实并不能很好的使用</p></li><li><p>聊到了IGP的防环策略，那就聊一下BGP的防环策略吧</p><p>a. AS路径过滤，就是当收到的路由更新中包含自己的AS号，就忽略这条路由</p><p>b. IBGP水平分割，iBGP不会把自己从其他iBGP邻居学到的路由转发给另一个iBGP邻居，但是可以转发给他的eBGP邻居</p><p>c. 路由反射器，路由反射器允许一些路由器作为反射器，可以将从一个iBGP邻居学到的路由反射给其他iBGP邻居，解决了需要全连接iBGP才能防环的问题。路由反射器RR会接受与其建立iBGP连接(客户端)以及其他IGP连接(非客户端)的路由器的消息，从从客户端学到的路由反射给客户端和非客户端，从非客户端学到的路由仅反射给客户端。</p><p>路由反射器会在路由更新中添加Originator_ID，记录原始路由器ID，当再次收到相同Originator_ID的路由更新的时候忽略。</p><p>同时如果存在多个路由反射器，每个路由反射器会在Cluster_List里添加自己的Cluster_ID，如果发现自己的ID，就证明集群内循环，直接丢弃</p><p>d. BGP联邦。也就是在AS内划分多个BGP联邦，每个联邦自治，可以使用联邦AS号来避免环路</p></li><li><p>BGP和ISIS的区别</p><p>a. 一个是EGP，一个是IGP</p><p>b. 运行层次，一个运行在TCP的179端口上，一个运行在IP协议之上</p><p>c. 采用的路由算法不同，一个是使用路径向量算法，一个是使用链路状态算法</p><p>d. 适用规模不同，BGP适用于大规模组网，ISIS适合中大企业内部组网</p><p>e. 策略控制力度不同，BGP支持更加细粒度的策略控制</p></li><li><p>BGP和其他协议怎么互相学习</p><p>BGP有IGP路由引入</p></li></ol><h2 id="BGP的属性"><a href="#BGP的属性" class="headerlink" title="BGP的属性"></a>BGP的属性</h2><ol><li><p>Origin，路由来源，是通过什么协议学到的，比如IGP，EGP，还是重分布</p></li><li><p>AS_PATH，途经的全部AS号，主要用于防环和根据路径长度选路</p></li><li>Next_Hop，下一跳，iBGP一般不会修改下一跳，eBGP会把下一跳修改为本地路由器的接口地址</li><li>MED，多出口鉴别器，主要是影响其他自治系统如何选择进入本自治系统的路径，较低值优先。仅在两个相邻的AS之内生效。</li><li>Local_Pref，本地优先级，主要是用于选择怎么离开该自治系统，同样是较低值优先。</li><li>Community，主要用于路由分组</li><li>Weight，某些BGP实现商的特有属性，主要用于最佳路径选择</li></ol><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li><p>说到BGP，了解运营商的单线或多线处理吗</p><p>主要是一个网络的ISP接入情况，单线指的是一个网络只使用一条线路或一个ISP截图，简单直接，但是会出现单点故障问题。</p><p>多线处理也被称为BGP多宿主，指的是通过多个ISP接入互联网哪过，通过BGP来管理优化这些连接。</p><p>多个ISP每个需要有独立的AS号，每个ISP之间需要建立eBGP对等体关系，配置出口策略和入口策略等。</p></li></ol><h2 id="BGP邻居建立过程"><a href="#BGP邻居建立过程" class="headerlink" title="BGP邻居建立过程"></a>BGP邻居建立过程</h2><p>输入peer ip as_num as_num指令后一般会接受这些</p><ol><li>建立TCP连接，首先要在两个路由器的179端口号上建立TCP连接，建立成功之后可以初始化BGP对话</li><li>交换Open消息，主要包括双方的AS号，保持时间，BGP标识符（通常是IP地址）</li><li>参数协商，主要是判断Open消息的参数是否正确，正确就进入Established状态</li><li>Established状态要定期发送Keepalive消息来保活</li><li>然后就可以发送Update消息了</li></ol>]]></content>
    
    
    <summary type="html">让我们来回忆一下BGP都有哪些内容吧！</summary>
    
    
    
    <category term="面试" scheme="https://www.karlyn.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="项目介绍" scheme="https://www.karlyn.xyz/tags/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    
    <category term="实习" scheme="https://www.karlyn.xyz/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>项目介绍</title>
    <link href="https://www.karlyn.xyz/posts/project_introduce.html"/>
    <id>https://www.karlyn.xyz/posts/project_introduce.html</id>
    <published>2025-03-18T11:30:44.000Z</published>
    <updated>2025-03-18T12:41:18.737Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="06b561f5d4d4b33d7e56ad635036990402ec2713029d3295d8376cf46cf02a53">a8b0df52fc69ea18510492bd532eeda59897709f31906e07cd42719165d58a20076af797e96049cbf0fe5aa619a8a7514e4254db6a4d13e596f84f3a74c645f47b2b1f93dc2e6f9c413496fe89cb38abd72057ad5fb77fb9902f07d2efd335a9da90ce965cbd987372f08215338effbef10ed5b89fdc9d1f24a9f8b34e65f894648fe975aaed73bb19bddb943fa375c142143525dafeb27eb0e2e9972463e85e6d0ee39177694db6bc005ca4733f995ae09e6ea2a0833fa50aca4ed9f3d912bcf3d52053619b69064bb721870f9812fc87f515a63053cfdac4882f3421eae8fea5f5d033d17ee766631231adc518013b4322e1a3c4e51bedb48d317d899fc4e9df55295e97988e471f487bfb696c557c12671749dbd729ee86c3809d2e428736fed1634938ef836fb367c41cb0dae33612bf27412a032507d223137e59755755f35769dac05c3536bde4254ee8ea645e4429813be4880a4d62850b0bb5f39a4817b3c75b6f762d752aa8f4d3fdc5dc499227c16a551443fa08ef009f320d09eced941a933744b5cc7df1aef46f965bba5742bf57ce9f359eca871093b3e9f8ac068b8fb188507a246baa153caa0d63a3e96cbdb7ceec075e6c9f03b85d1e221bb9d431bbbcad0ae06bea37af4bc519ac5b4055ab3e01384f0962c7e8e6d7b7b02adf5e23d71ea0ac176b72cc568482f3ac053274bd2b7400d70f2c0962f84fd0a848a84dcbf66dba2e533b99cc8f960402756a048be4084bdfd309e94fb893eade6a49b437218253cea067fa230c5092da05d481ce76de989cfcef88201230a8838bf84f6faed999cfd2fe54f9053170f33fd4b2d2a022e031d5c09dfced661cde6d3b2cb904bd1a61568cec82eda4600c15d3940025fab3c9c98e1db8ec667baf9bb5c6d9a43b3159761b5c61f10c5d9059753312c4f867df15fea8ae82da0e91ed974049a43ac298ad53d99e1932057ec66f8511bbc71e99655784aea0f4a98d12666161e8b4c5878defeae55e98533bb125871f8624fe1faba9f8c95481a8282665d081ced3f978ec2de69898ebeabf2b8e490d0c650940a86bb40c9bdbd17d6c06331936283757feebbc2ad0cb7d59335adaac57c5b747bedc2083255a503b1eb1ce258b2f4861054b3ef7fe366ea4fb3d7a02fd431566150fa3e86f9590ed1ff3292f3dadbd1712ae4e8132f896da19b2f22080c4db1db6d85cd278852291616ae4524285bfbb75c55fe93c07bcea3c341a54781c90c6c4af185ad50d54a6b3d57e9695a3e84d4d8f6fd3c6194fdb368d1e4e3f5461bae8036771d32d1bacc212586b27de2e2b3ffe5a0a20c3701389cafa335b6c430c0cae07660636fbca1771fc2f51bebbbdc47f155d62d0ece66ba6e02ad4225b99f53fbaa5ed7a3e1a2d327dba93e486a81f29dee5d3b10d59dbd76e64d88b0fa9dd9d4216f5b9c049b95deb6fc33d5ca65b2cfadbc16b115512e18222769b7e17b734cae42405fc5397ad4aa3121f8d14a1ddf0ea12d6e0f4b68f0fce8b8c9fd1f73d07a2ff5f56fe97e7d3d6f9fcc26d187cc71c72c746fd3b2c5f82980c6e211a096fdda3635762fda9914be1513706f2739eaf3f18821654ffe3728354f2b491cb1a74651e774d628c3834e192aa6358dd6cc64f83fda4fd01c1e8a7bf4320bb552f478750846948a3b63e2b05e548e15dc25f81a822c2cf5c03ebe1ed2f194bd45bc9494771da29adef8efa3f62ed3972c6338a61c4095682a8086082c8d5ff3af820c3d3a18a8c7993bd2f1a056546b72acb214aa2062c807b09fef4458fd0a05c5600d7ec81d561da2348468dd7852ef2c574705ebdffe01afde810950e50ffc152a20ee6cf4d608c4176fb19a75e9546caeb42230dc76de5c33c36b6273a98a63b4188acef6439b460e10ceb5479b86d5d81166c0d882b6b656de7748bb566a9cb0bb030266ed0e1b5209bf98e9d65dab96f350c00ae6743b8b2db923beef6048e1ed59ae69a8e1f58a1b3f54d24fdb5ca6ca679031373ec677134e669f5581bdab23a50fdddf14e094329a9b226075c27afb6e99393476e4705a6c320951da3b8f02f9a6e4157c1ec386f558dc8c0014927765179212e678996826d91c5da98f366d2e91c585247873ac22046260cec4a99ef641c0c5d946172b1eaf29ffa20d3aa8828a23cbd3a98741461b815d392e3343cb2a63ebd6a6e7133a9496c3bd77d640b3cd2d52aa6e9284f7e026b2e7c5d3bce8a200bccaf909137cad2e9aca61b7dc23a438d2141aef837f3a78c7d202dd703c81fc567e1f9504fdd351726d952424d024c9e276ff661a232cfb2a18d6a8a692ccff8cd235eadd61ee6b414c2bb4025c1d391b4bf6a7ec3715a0f3edf4d0027fb6e69ba1c7782be13030888175324c6b3ee0f0264cb3fb89b52c59c0c1a4b38552cacd8e9c89da53ddd799122e36c2f3c66b873e73cb4dac51c8eb209618b5c9e55a80987e5a01313d63e80eb6bd5f5644c5a9b0f0154fa379add8367553c4a590cefc242018bcd290a54de3b68d7435de3e987c8f38fa8463cb18505906b3c270837cf2d309e15632c3bbd3c312fe2ad132f9913e2a87c3aeb4e7dcc091562442e59b2d7f4538780480f646791b1f7b9815a2c03ab9b797d7a71c0742d52fa46d120c71900f96587157e499c807e8f2721cc9a5f4deabc9c943aa8656c177a457bda879a0f952442d53b0553ec64b4f6e84d3d4af8e870d5397adcec8975e941495de566da3f922bf13465d89a9c4d262a2c02a98aff759dc1e6e193ca105f0bf6be7fcd3aeb9c3bcae74842e2456f8d252d475832c2ad1452bd17eef92bcdf3f76ba10fda2df445dff2766e96730d61a660890bb94da3913ee5147604d07f63edfc95206b59449cc0971981247056a649a07f59c147e0b707d7af4c35c960f413a2e1fdb6f4dce3f2b75429bb03388759e68720bb732ee8c35c583f63eb4425ba22a1f7652b108a44d4bdc5e714f5edbe3a6a6a19580150d701a02147be930c61fee97d69ac0d56ec76bec510dbc43717899fad60b3d57ff30e792145e73744b5226c7fdda157575c5a7eaff28a8df503b9f8fb6fbb73d7b44437d4d7b523f74908c26a733e52c8d343699efaa5a082f6c11e470673223deeded2c2976d4246891dd6187c0911409558e35da1b702fd36aa055cdd0dac6d6cffec3679292ec6103b243a5967fd72a3c62dcab75c9cc6b69dd910997cde82e9b62c43f11e115fe6c39287d3fe5448cde1bcedd4ddda0ae9f5db8bdfeefda995253cb20178f642b9c76ecbc5b9ff075de94683f0467133717073c209f6f1656f70afd2729eb696db5ae08110677de1aae201e35f3f1eb0d62332b763077a0e7521c0f676a39e88e94f55cdd8b17b5454f40dbe904569878d0e8a0fc6a2592f53fad5a9b920f82e2cc4c8c14042faa14c91ab225cf9cfdcaa0f21ab76a836e7993b581bfb0f1486deb4e2b626f2d725f90a67e683de741d1d76f8e5677de44390256fac0c97599f7f61b669de5c8efb28236c421c462e3fcbd6c9678bbb7b03a742da0c8d152630ec5f6a5796dd3ad62621fc46a9a760ade2a92c7f1dfa09f2008ed6dee1032fd4748e5d4bd0dff876b604d49da2dad4e7c08790c20507054882c0e404ca98593e9009f2e4efbaeb81b5e911c42e6f57a81aae82dec2ef603cd5440bd0adff218f0edae8da2c7767625660218c05550add7df58aeb9e29ac9f8d2797a9268d5433aae5633d65d6fc73e8d9c495e28014257da569cd776dc1f9e32c5a37f65a9daf669eea34683956f504a067da3512213439a24d6fa17d6ceb5ec1ce0459a9faddc6fe0ab26070c3f38bbd90c3f24192cac625d7da5ae4d58af5f9ad611def0b8ec141ce86bfae2f8b854cc3d9bfad17d5a4d905ffb054035b6184e85ac92ffb527f4ce0d30dbc9c9efede591b2261c6a0d9c7ddff69693516df2ff52d7dcc53ce724ea2fb96f28f76eecf0df8a0aaebad66c11e5f42657d2d3715ea5c5d3fbe49333568505f8f494592865a22aa8c4c42f704b378cbcfb9acbc91790ebcd2cb2f4f1a84868ae1ec838caf0b241f6d72d790f029004bd0476b365c52b55165b5ae736d76a4984a61c5c16a200c3946d67fe83366ac71a0218a1f5369e631b7e105e4000b2c2c89339356c9c60de767d9d561ba4ec327cbb48dd756c0bfa688b82c8ec8be8ff37fab33e0f2f15b08c465a23061e7a6903f856cc5ab1edb20ede41e3e3e57f81ba20c343a338db9ce72a2a2a30936d4b17f9bfe712a93b5af730a01a21b626fb9ecbe4118c1a61de7c47b77dde7982a5052e7c1da77e6483bc3c6df0c3dbb32872cd31925f134c1c0015278b2386eb801787d3d976e1f0dd84cc16c9e91ba8beaa87e575379cfdfebb3c1ac59e6460f73b698c802209c37063151d6b7a39a906c7d3fc2a40ea62f4c8db17fea7fa162f9e24485248ed02d2e36c1004829344b165380abb8d1db27b510956e5dd075cedf3bf0ee106844833f2450a649a0a14610b361131b3dd8789795f6700680d9aa9b5bc9551d5d03889aacaa68ed1335db95312bcdf1f5caa593ca92f159c43c055f82d045f572c431d6da9d8c0477a89734c87037031ce499d8cfbfb7bfbda58c5372ea44a0c7ecf3b041f9b2e1edf76348e9bc11808dfb707b986cb2a1b73201cfd75e746414c3b8e4035b02fde2f127e0c84813f2588fbd1256d695c5ebc66e0881abfbfa8bee6fed56fa1b61367f03bc716bc75b0884b227201dd0db63c576d86bc88215206e851bc82e338a460df66de1469bbb2cb6c8e724a96940bfa86130fb0cd83492acff5c35e6ade8d0be3f0e27d58e486197ee4f0b1ad26f85fc052e9a554175820b80e709ac3854d34b85be2915d254fe437559ac4a4b54c93e3c0b16e4dab97475e84abe2dd13dd09f4ca37a4b014c57a7e662055a78bc2f5908521814aef22430d18df2ac60276fb0ef53cfb80691b6c1b37085b834f8f6b555c398be97054a8ad250e26c23911ace5b231e560ba6a7bd6c2aad821ed6ac4af9bcd7782bda51da4d2007a0a71c6f0cd0fabcce87f62d4843d66b8d47496e9271741414845b075cb0075a226641a36f8390aceb85a943b8ef879e0593f511d2fd0157b81a16a95e72081794f617db65d8ddc183092ecc7d7e0a38f286f0a19e3e7c9929e92e57bd9e8672af6ed01f1f999df5885540e4995ed0617d3b7a3c15bfb9cbf7303b40be4694816abe2fa153f6c39cc348bba98f554eccae2fc1c0d815aafeda9fa005624af14984d3eb3b38d041b3859f6eeb96e7c8da81aa93cfee03fbf504c74ecbe89b1c2e5db74901eab045ac9940d921a9fefc5530e3f6b3983335bf2906aa974645ac23ba93f0b865924fae98ea67a09ce1120c348361563e3af8424fa5c861ecc5af863f3fc4181133202571e3b3aabcad8813e6c1aaece85f23fb0e1aabd08f9c04acfc866c5ba1c70d1c27ea2d2e4e199d14eb83a2891a6c09d8c0e1e41556bb8b4b9a9df16b86fdd71d25e3d205a4a4f098f5434c8c3707555d5c893f4a7d7a55c2fb8c48eabf3c884c0003e57fe53d7c0ec59b93cf2773079d70a24284d5918654ac4d5772e974f5d36bc03286c8a30d081fe85fca7b87056f09023d2d6dae806dc0bf2650e00a68f220f431f249fb5d783b89129579456bcc614a391348b5b5c7968d55db6bcd44ea8c76c941bb6f1dc8ac89dd0b153cd9b1a862f8e64c7da308c5bfb3dd9b82bdb53a9c854fb2f15cfbb3404e5cc38dc274aee3e8dedae5bd7b1bc3f7c9325058ba86d0e8413fb4c3e39ffbc0ba11c3bddc931afb4f6f7ae37a03d7aad12617d0eb21edd08547d426698c5288100b214198ceec2a8729894187a073f6e5195efa38f115a7f0b529277dfad1c8f1712f7dc3e22b9172d84650983a03277571c5a50d4cb75576908dd4956497d30889c4bc2420cc7607ffa8f1f05bbaf796310455834c6edb049633e3aa5679e653e084c29847fe066e3cf80a51a71749e16d25eb50c256361c57a5ffb63a8e5a396907c2ff8f434ed2219c4912bf0ddbb26bab37776e99df1fa9968cba24cf1c71528e6efce2944277780b108710aa0ade77f403b536ce3f347057fa7ee7f6b9f4e43fd9dc33db37662622c2085feec5fbeb8543aded1507c06d0c6f80eae27a68a9468f6b49c3b7b5cf5a4889715be876f601ac7baaf283649a6222aa9c2b913bdb96ea80e2616bfb89514c1e3d64f6751ee45f619c4f3c4d98c5d77247b94a2ced8837e92dd8cbe54f18cb2ef0241f2be3d65331b306056a0c248682b4ca0eaeb37cccd4b3b40d6683895519b3aef415ca4a88d7fea256e77a3f55381166ee307e992bf31c35cee8ff3707294d0eb6f7bc13bf902eb5686f122ab4b699a0dc322e05e379ea9e86b0fa4a805ecd45872c472f96275d8b1507e452f68f86f68f6334489aca445811abc2e41b82a585586d082e3efcd75bd40f7432ee94fe9ea503d6378950dad5c8c60028d36149218c84479f80bc5c806f714e894341c298e2a8d29b442e0c686861c98e7de88e39cb548d834d80f756fd2f28ce9454f5d43eb8d2817d9e5d97f14916d621096e2ffa7b4cab14f553f682d191f61c62b039b91fe4f2e153e1a9f8b34135247fc4811ce74ffe0fb4170b5aa99d1a70577c1d32c3e0374936ef80f2a1a3d782e04c35f620c2e9b72843691fe69530d9ba2d194a3c06fd11d367f7eff7e48240133b537e7e55438ccf51b9559304ac6fee1fc7991908f7d6813a7e711227c93c55396423b9817ef0a218a3628887c68bc9f2b976034b4d98984d042aa4431ceb31f13e12f1dfa020459606be1332b96a6cf3a5aaa0a37842c7a62330e9ca949f2c04e58eb9e5a4b4a1df39af00979c6039d60bef376b47fb1b475859aa93df4b58a49c0580817e8554100c87720d253ebf69c5919869955a06c2dba4da957992fc2ec2e8387e07c8d5aa416f5975e1e0bcfc36f5c188396dfb7c13813225ecffc5717d4eab411645361ad8cbe9229b98e2e683b0597c81c9014febbf94c2da38e56461a4b476f5def2b17bc563553f9143a7c404ba97e4309466b73cc60160eb873b9b50331ec574c212ec94ca02554f35f5bef5d2023a27f129fae2bfc9b287f1063d98e0258dd6bf29d7738264ac08e0f4815d83f4a34d544158975662733913b10302e6af26bb9e94df5404f4d7ec040a341e0f792b60a587be46b45ddf12f64adba4ae1cafaf3d23713cfc5363ce1f9c40b9f12a67ee9f032b6103b01fe541afe709379bd70e213f1cb0918f5249c978a97113ed3ef69a29893d48bc3a2f6d95cccbdadd092475477c26052d31720fee49d5fdbc661cbffb08ca211641ad396f0fb1ed487d1dc44c9dbbb52df652a236ea9fc373c54840a5bb090b505c8fbb306deee971b13e8177eaaef487df755c3f02684804941ca4151e88179711f0e2a4530a7a56fe1de1be460092f37794a2b74b2e9285acddf986bbe758ae1edfd97c58d1b2e04eb7bccc3230d0fb77b541e958a7fc74df2c7071a1a4dc085290227d011ba4df2efcfb6a4f4cd1ce49b194ffe57b5df775165a3ceccbc452b815b0601e73a1b42f2281066216148af315481583a3edd3f159de48b012cf3079c5ae609a3d8a3d2608dfbd42d7f8ec3621128965af753ad4f8a9d6368c921da198c5bdc11f5f7961f73276464d2449d498bd9aa8f1b6b4a31a0168831aa22f0d9aa3c3f9948748012a149ee902ed9089575345d691cf689d77035e0df2089eb878dd4ee3f672c6ca18e534aa73c2d9fdae366b7e774178e36c8b4e5b7bdb137c96386da6ec3e8e968c300f71f2035ef55cebce9e2a0a6c96aa113e12c9cb149d9b30493cd90d45f755e6ee3606c82375eca06ac4419685d5ea94108aa7b4086f4de389cda97e50ee3914272821cda39f80e1463f9fdcc6cda974c6d581cb6213aa5a13e32e164ad5122f12ae83dea6f974a310d614d121f9045ba9b8fe290994427f63e752eb33dcb8b8019325051cd06f1926842a8a5043d85666054a774c63d47c06ed7898b7b337e330b7229f5905dc2028a9654a2c1b6dde521c0df960f6198ad6439ecfe7925f5572e8324788d5d28746fe8a5be7fe4188723178e747f7a6f520d6bcf3b024a7ebb13fa1aaea237ee613ab7c3c53c62c050fcee6b6b6dbf31eeafc53b725afc13d37e8ee8788901e04b3f5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">Hey, password is required here.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">主要是整理一下怎么介绍我的一些项目</summary>
    
    
    
    <category term="面试" scheme="https://www.karlyn.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="项目介绍" scheme="https://www.karlyn.xyz/tags/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>K个一组翻转链表</title>
    <link href="https://www.karlyn.xyz/posts/reverse-nodes-in-k-group.html"/>
    <id>https://www.karlyn.xyz/posts/reverse-nodes-in-k-group.html</id>
    <published>2025-03-18T08:42:03.000Z</published>
    <updated>2025-03-18T08:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h1><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&amp;envId=top-100-liked">LeetCode原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="示例1"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="示例2"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这题难度被划归为困难，其实显然是不能达到困难题的难度的，只不过如果不习惯封装编程，单独将反转链表的方法单独写的话可能会有一些边界类型的问题出现。不过提到了需要使用 <code>O(1)</code> 额外内存空间，前置题目为反转链表，题目链接为：<a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">反转链表</a>，只不过反转链表提到可以使用递归或者迭代的方式，但是递归的方式显然需要使用系统栈，无法实现额外内存空间需求，所以这题几乎已经锁定使用迭代的方式进行反转。</p><p>首先我们先尝试做一下反转链表这道题目</p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="示例1"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><p>官方定义的链表结构还是比较简单的，没有要用户自己定义链表，有些企业的面试题是需要自己定义的嘛，所以我们也简单自己定义一下，防患未然了属于是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*定义链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line"><span class="comment">//空参构造方法</span></span><br><span class="line">ListNode()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ListNode(<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="built_in">this</span>.val=val;</span><br><span class="line">&#125;</span><br><span class="line">ListNode(<span class="type">int</span> val,ListNode next)&#123;</span><br><span class="line"><span class="built_in">this</span>.val=val;</span><br><span class="line"><span class="built_in">this</span>.next=next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现任务之前，先简单实现一个输入获取和结果打印的方法，便于本地自行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">readDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    String[] vals = sc.nextLine().replaceAll(<span class="string">&quot;^\\[*|\\]*$&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span>(String val:vals)&#123;</span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(Integer.valueOf(val));</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printListNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> != head)&#123;</span><br><span class="line">        sb.append(head.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是正常实现了，我们分为两种方式实现吧，首先是比较简单的递归的方式实现，递归的方式就是不断把后半段反转然后作为前半段的头部分。</p><p>我的代码可能有一点唐氏，讲得也没有官方的好，所以我贴在这里，简单介绍一下，一些注释基本代表了我的想法，需要注意的只有一点，就是需要先翻转后面的节点，然后再和前面的节点拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表的递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 后面需要反转的链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pre 已经完成反转的前半部分的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转完之后链表的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseListDFS</span><span class="params">(ListNode head,ListNode pre)</span>&#123;</span><br><span class="line">  <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//定义递归终点，也就是最后一个节点，直接把它和它前面的那个节点拼起来然后返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head.next)&#123;</span><br><span class="line">      head.next=pre;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果不是递归终点，这部分就需要理解一下</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//首先是将后面部分翻转！</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> reverseListDFS(head.next, head);</span><br><span class="line">      <span class="comment">//然后将改节点的next改为pre，拼接起来，顺序一定不能错</span></span><br><span class="line">        head.next = pre;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reverseListDFS(head,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让我们来实现一下迭代的方式，迭代主要还是双指针的思路，其实相对而言思路比递归更容易理解一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表迭代实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转完之后链表的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseListIter</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//定义双指针，这个定义是有技巧的，因为头节点的next要是null</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//依次设置前指针的next为后指针</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> != pre)&#123;</span><br><span class="line">        ListNode tmp=pre.next;</span><br><span class="line">        pre.next = lst;</span><br><span class="line">        lst = pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前指针为空时，后指针所指着的位置就是最后一个Node，也就是我们所需要的head</span></span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后反转链表部分我们就基本讲完了，但是迭代这个部分的代码在后面我们还需要进行一点小小的修改，为什么呢，因为K个一组反转链表，链表的终点不是null，而是我们需要的终点是第K个节点。</p><p>接下来就是K个一组反转链表的任务，简单来说，我们只需要把任务拆成K个反转链表的子任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseSubList</span><span class="params">(ListNode head, ListNode last)</span> &#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//定义双指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//依次设置前指针的next为后指针</span></span><br><span class="line">    <span class="keyword">while</span>(last != lst)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        pre.next = lst;</span><br><span class="line">        lst = pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//当k=1的时候，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == k) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//为了统一以及便于找到头，我们定义一个伪头部，其实这是很常用的方法</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fake_head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    fake_head.next=head;</span><br><span class="line">    <span class="comment">//如果k不等于1，接下来我们就需要定义一个节点，这个节点所需要做的事情就是找到每组的第K个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">findK</span> <span class="operator">=</span> fake_head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst_one</span> <span class="operator">=</span> fake_head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里只需要判断findK是不是空，因为它一直走在其余两个交换位置的指针的前面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span>!=findK)&#123;</span><br><span class="line">        <span class="comment">//如果不是第K个，直接后移，不做处理</span></span><br><span class="line">        <span class="keyword">if</span>(count!=k)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            findK=findK.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是第K个</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//重置寻找循环</span></span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//首先是获得子段的头，子段的尾就是findK</span></span><br><span class="line">            ListNode child_head=lst_one.next;</span><br><span class="line">            ListNode K_next=findK.next;</span><br><span class="line">            <span class="comment">//然后进行子段反转，这里会把它的头尾都断开，所以之后就需要重新拼接</span></span><br><span class="line">            reverseSubList(child_head,findK);</span><br><span class="line">            <span class="comment">//然后将前面的子段和尾节点拼接</span></span><br><span class="line">            lst_one.next=findK;</span><br><span class="line">            <span class="comment">//将头节点和后面的节点拼接</span></span><br><span class="line">            child_head.next=K_next;</span><br><span class="line">            <span class="comment">//重置last_one和findK</span></span><br><span class="line">            lst_one = child_head;</span><br><span class="line">            findK = child_head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fake_head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只能说，很优雅，但是还是建议大家看看官解，我写的很简陋。</p>]]></content>
    
    
    <summary type="html">看懂这篇，反转链表系列就都能看懂啦！</summary>
    
    
    
    <category term="刷题" scheme="https://www.karlyn.xyz/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="Hot100" scheme="https://www.karlyn.xyz/tags/Hot100/"/>
    
  </entry>
  
</feed>
