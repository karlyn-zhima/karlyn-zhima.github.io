<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhima の blog</title>
  
  
  <link href="https://www.karlyn.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.karlyn.xyz/"/>
  <updated>2025-03-19T09:07:57.572Z</updated>
  <id>https://www.karlyn.xyz/</id>
  
  <author>
    <name>karlyn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快手暑期实习一面整理</title>
    <link href="https://www.karlyn.xyz/posts/kuaishou_shuqi.html"/>
    <id>https://www.karlyn.xyz/posts/kuaishou_shuqi.html</id>
    <published>2025-03-19T06:56:53.000Z</published>
    <updated>2025-03-19T09:07:57.572Z</updated>
    
    <content type="html"><![CDATA[<h1>总体整理</h1><p>先总体回顾一下面试，其实发现面试官更希望的是能够提纲挈领的回答很多问题，而不是回答过于细节化的部分，有些太细节的内容反而会让你表现的很凌乱。诸如问你设计I/O多路复用的目是什么，其实是为了解决效率问题。</p><h1>框架部分</h1><h2 id="说一说Spring和Spring-boot的区别">说一说Spring和Spring boot的区别</h2><p>其实Spring和Springboot的区别还是蛮多的，接下来我们就简单聊一聊这些部分</p><h3 id="相同点">相同点</h3><p>其实SpringBoot是基于Spring实现的一个更为轻便的脚手架，他们的核心模块同样是：</p><ol><li>IoC，控制反转。控制反转的目的是为了解耦合，是将依赖关系的管理从应用程序转移到一个容器或者框架来实现松耦合。简单来说，传统的编程是直接创建他们所依赖的对象，而在IoC中，这种依赖关系的创建和绑定被外部化了，也就是由IoC容器负责。</li><li>DI，依赖注入。允许对象定义他的依赖，但是并不直接创建们，而是由IoC容器提供并注入其中。常见的注入方式包括：构造函数注入、方法注入、字段注入。</li><li>提供了AOP，也就是面向切面编程。支持灵活定义切点和环绕。</li></ol><h3 id="区别">区别</h3><p>区别也是很明显的</p><ol><li><p>Springboot首先是遵循了约定优于配置的原则，很多时候开发者所做的选择是一致的，所以不需要开发者手动配置每一个细节，比如Bean的扫描路径等等，当遵循这些约定时，框架或工具可以自动完成许多常见的任务和设置，从而减少了配置的工作量。</p><p>基于约定优于配置的原则，springboot进行了很多自动配置。当你在springboot里引用了一个起步依赖，springboot就会对这个依赖进行自动配置。</p><p>举个例子：</p><p>如果你在项目中添加了<code>spring-boot-starter-web</code>依赖，Spring Boot将自动配置：</p><ul><li>嵌入式Servlet容器（如Tomcat、Jetty或Undertow）</li><li>Spring MVC DispatcherServlet</li><li>转换器（Converter）、格式化器（Formatter）</li><li>静态资源处理</li><li>错误页面映射</li></ul><p>添加<code>spring-boot-starter-security</code>依赖后，Spring Boot会自动配置基本的安全设置，比如：</p><ul><li>HTTP Basic认证</li><li>CSRF保护</li><li>Session管理</li></ul></li><li><p>Springboot的内嵌服务器</p><p>Springboot默认支持内嵌Tomcat、Jetty等服务器，使得部署更加简便。</p></li><li><p>不同于Springboot可以用starter扩展，Spring提出了spi的机制，允许第三方开发者为Spring框架提供自定义实现，使得Spring的扩展变得更加简洁。只需要自己定义完成一个AutoConfiguration加入到AutoConfiguration.imports文件中去就可以自动加载了。</p></li></ol><h3 id="了解SpringMVC吗">了解SpringMVC吗</h3><p>SpringMVC是是Spring框架的一个模块，专门用于构建Java Web应用，遵循Model-View-Controller设计模式。提供了丰富的功能来处理HTTP请求和渲染视图以及管理应用程序状态。</p><p>分为几个重要的模块和过程：</p><p><strong>DispatcherServlet</strong>：SpringMVC的前端控制器，负责接收所有的HTTP请求，并且使用HandlerMapping找到他们对应的处理器，也就是Controller方法，如果找到了对应的Controller方法，通过HandlerAdapter调用该方法</p><p>Controller处理完成之后，会返回一个ModelAndView对象，其中包括模型数据和视图，这时候就需要进行视图解析与渲染</p><p><strong>视图解析与渲染</strong>：<code>DispatcherServlet</code> 使用 <code>ViewResolver</code> 将视图名称解析为实际的视图对象，并将模型数据传递给视图进行渲染。</p><p><strong>响应生成</strong>：最终生成的 HTML 或其他格式的内容作为 HTTP 响应返回给客户端。</p><h3 id="之前我们聊到了IoC，顺便聊一聊bean的生命周期呗">之前我们聊到了IoC，顺便聊一聊bean的生命周期呗</h3><h4 id="先简单聊一下一个对象的生命周期吧">先简单聊一下一个对象的生命周期吧</h4><p>太经典了这个问题，这个图永世流传</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/522bcaae8318b41975643d19918c75cd.png#pic_center" alt="对象的生命周期"></p><p>必然会问的啦，类加载阶段，主要是做了三件事情：类加载器加载（双亲委派模型），将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口</p><p>然后验证、准备（给static的基本数据类型赋值为默认初始值，对引用类型赋值为null）、解析（解析阶段就是虚拟机将常量池中的符号引用转化为直接引用的过程）、初始化（根据Java显示赋值的内容进行赋值初始化）、使用。</p><p>最终的卸载分为两类，一个是对象的卸载，一个是类的卸载。</p><p>当一个对象不再被引用，即不可达时，该对象就会被JVM垃圾回收器所回收掉，从而结束对象的生命周期，此时类在方法区内的数据并不一定会被卸载。</p><p>而类的卸载是很难的，一般来说使用Java自带的三种类加载器（启动类加载器，加载Java的核心部分；扩展类加载器，应用程序类加载器，加载环境中的Jar类）加载的类在虚拟机的生命周期中都不会被卸载。</p><p>类的卸载只有三种情况才会触发：</p><ol><li>它的加载器被回收</li><li>该类所有的实例都已经被回收</li><li>该类的Class对象没有被任何对象引用</li></ol><p><strong>所以类的生命周期为：类加载、验证、准备、解析、初始化、使用、卸载</strong></p><h4 id="说完了一个类的生命周期，接下来我们简单聊一聊Bean的生命周期呗">说完了一个类的生命周期，接下来我们简单聊一聊Bean的生命周期呗</h4><p>Bean的生命周期主要包括：</p><ol><li><p>IoC容器根据配置文件，实例化一个Bean</p></li><li><p>对Bean进行依赖注入</p></li><li><p>对Bean进行一些Aware的初始化，比如如果bean实现了BeanNameAware接口，就给他set一下name，BeanClassLoaderAware、BeanFactoryAware同理</p></li><li><p>调用BeanPostproccessor的before方法</p></li><li><p>初始化Bean，也就是调用Bean的init方法</p></li><li><p>调用BeanPostproccessor的after方法</p></li><li><p>使用bean</p></li><li><p>销毁bean</p></li></ol><p>值得一提的是，Spring IoC自己能管理Bean，自己可以调用Bean的destory方法，不通过Java的GC回收bean</p><p>一般是在Spring上下文关闭之前调用所有Bean的销毁方法</p><h1>中间件部分</h1><h2 id="聊一聊Redis的特点，以及为什么要用Redis">聊一聊Redis的特点，以及为什么要用Redis</h2><ol><li>基于内存实现，数据存储在内存中，因此读写速度非常快。</li><li>单线程，但是使用I/O多路复用。</li><li>高可用和扩展性，支持主从复制</li><li>支持发布订阅模式，允许客户端订阅特定的频道并接收该频道上的消息。这使得 Redis 可以作为消息队列系统使用。</li></ol><p>使用Redis可以有多个方面，包括作为缓存、保存过期时间维持心跳等。</p><h2 id="聊到了I-O多路复用">聊到了I/O多路复用</h2>]]></content>
    
    
    <summary type="html">整理一下快手的暑期实习一面，面试官人还是挺好的。</summary>
    
    
    
    <category term="面试" scheme="https://www.karlyn.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
    <category term="面试整理" scheme="https://www.karlyn.xyz/tags/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>BGP整理</title>
    <link href="https://www.karlyn.xyz/posts/bgp_introduce.html"/>
    <id>https://www.karlyn.xyz/posts/bgp_introduce.html</id>
    <published>2025-03-19T01:46:56.000Z</published>
    <updated>2025-03-19T02:46:39.410Z</updated>
    
    <content type="html"><![CDATA[<h1>BGP整理</h1><p>主还是整理一下BGP相关的内容，毕竟有一段在BGP的实习，防止自己逐渐忘记。</p><h2 id="简单介绍">简单介绍</h2><p>BGP也是路由协议之一，主要用在AS间交换路由信息（eBGP），当然也可以用在AS内交换路由信息（iBGP）。</p><p>与其他路由协议利于ISIS、OSPF等建立在IP协议上，RIP建立在UDP上不同，BGP建立在<strong>TCP</strong>连接之上，默认端口号是<strong>179号端口</strong>，所以我们这里有个观念，就是BGP其实是一个应用层的协议，即使它是一个路由协议。</p><p>BGP既然建立在TCP连接之上，就要求BGP对等体之间有稳定的路由链路连接，并不要求对等体之间直接连接。所以BGP所在AS内需要通过ISIS、OSPF、RIP等建立起连接，而通过BGP和其他自治系统通信。</p><p>BGP是基于路径向量的，这既不同于距离向量，也不同于链路状态。BGP所要传递的信息不仅包含到达目的地的最佳路径，还会携带所经过的全部自治系统的AS号，避免路由环路。</p><p>同时，BGP设定了很多属性和策略，可以根据他们来决策不同的最佳路径，包括：本地优先级、多出口区分符(MED)，权重等等。</p><h3 id="常见问题">常见问题</h3><ol><li><p>为什么其他路由不适合做域间路由？</p><p>a. 路由规模问题，IGP主要关注较小的网络环境，没有为处理大量路由信息而优化</p><p>b. 策略控制方面，常见的IGP协议没有提供BGP所提供的诸多策略控制属性，不能对流量进行细粒度控制</p><p>c. 防环方面，一些常用的IGP防环策略（1.最大跳数限制，2.水平分割（接口a收到的路由不会再从接口a广播出去），3.毒性逆转（路由失效的时候并不是直接删除，而是告知邻居自己与其距离无穷大））在跨AS其实并不能很好的使用</p></li><li><p>聊到了IGP的防环策略，那就聊一下BGP的防环策略吧</p><p>a. AS路径过滤，就是当收到的路由更新中包含自己的AS号，就忽略这条路由</p><p>b. IBGP水平分割，iBGP不会把自己从其他iBGP邻居学到的路由转发给另一个iBGP邻居，但是可以转发给他的eBGP邻居</p><p>c. 路由反射器，路由反射器允许一些路由器作为反射器，可以将从一个iBGP邻居学到的路由反射给其他iBGP邻居，解决了需要全连接iBGP才能防环的问题。路由反射器RR会接受与其建立iBGP连接(客户端)以及其他IGP连接(非客户端)的路由器的消息，从从客户端学到的路由反射给客户端和非客户端，从非客户端学到的路由仅反射给客户端。</p><p>路由反射器会在路由更新中添加Originator_ID，记录原始路由器ID，当再次收到相同Originator_ID的路由更新的时候忽略。</p><p>同时如果存在多个路由反射器，每个路由反射器会在Cluster_List里添加自己的Cluster_ID，如果发现自己的ID，就证明集群内循环，直接丢弃</p><p>d. BGP联邦。也就是在AS内划分多个BGP联邦，每个联邦自治，可以使用联邦AS号来避免环路</p></li><li><p>BGP和ISIS的区别</p><p>a. 一个是EGP，一个是IGP</p><p>b. 运行层次，一个运行在TCP的179端口上，一个运行在IP协议之上</p><p>c. 采用的路由算法不同，一个是使用路径向量算法，一个是使用链路状态算法</p><p>d. 适用规模不同，BGP适用于大规模组网，ISIS适合中大企业内部组网</p><p>e. 策略控制力度不同，BGP支持更加细粒度的策略控制</p></li><li><p>BGP和其他协议怎么互相学习</p><p>BGP有IGP路由引入</p></li></ol><h2 id="BGP的属性">BGP的属性</h2><ol><li><p>Origin，路由来源，是通过什么协议学到的，比如IGP，EGP，还是重分布</p></li><li><p>AS_PATH，途经的全部AS号，主要用于防环和根据路径长度选路</p></li><li><p>Next_Hop，下一跳，iBGP一般不会修改下一跳，eBGP会把下一跳修改为本地路由器的接口地址</p></li><li><p>MED，多出口鉴别器，主要是影响其他自治系统如何选择进入本自治系统的路径，较低值优先。仅在两个相邻的AS之内生效。</p></li><li><p>Local_Pref，本地优先级，主要是用于选择怎么离开该自治系统，同样是较低值优先。</p></li><li><p>Community，主要用于路由分组</p></li><li><p>Weight，某些BGP实现商的特有属性，主要用于最佳路径选择</p></li></ol><h3 id="常见问题-2">常见问题</h3><ol><li><p>说到BGP，了解运营商的单线或多线处理吗</p><p>主要是一个网络的ISP接入情况，单线指的是一个网络只使用一条线路或一个ISP截图，简单直接，但是会出现单点故障问题。</p><p>多线处理也被称为BGP多宿主，指的是通过多个ISP接入互联网哪过，通过BGP来管理优化这些连接。</p><p>多个ISP每个需要有独立的AS号，每个ISP之间需要建立eBGP对等体关系，配置出口策略和入口策略等。</p></li></ol><h2 id="BGP邻居建立过程">BGP邻居建立过程</h2><p>输入peer ip as_num as_num指令后一般会接受这些</p><ol><li>建立TCP连接，首先要在两个路由器的179端口号上建立TCP连接，建立成功之后可以初始化BGP对话</li><li>交换Open消息，主要包括双方的AS号，保持时间，BGP标识符（通常是IP地址）</li><li>参数协商，主要是判断Open消息的参数是否正确，正确就进入Established状态</li><li>Established状态要定期发送Keepalive消息来保活</li><li>然后就可以发送Update消息了</li></ol>]]></content>
    
    
    <summary type="html">让我们来回忆一下BGP都有哪些内容吧！</summary>
    
    
    
    <category term="面试" scheme="https://www.karlyn.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="项目介绍" scheme="https://www.karlyn.xyz/tags/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    
    <category term="实习" scheme="https://www.karlyn.xyz/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>项目介绍</title>
    <link href="https://www.karlyn.xyz/posts/project_introduce.html"/>
    <id>https://www.karlyn.xyz/posts/project_introduce.html</id>
    <published>2025-03-18T11:30:44.000Z</published>
    <updated>2025-03-18T12:41:18.737Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e0eddff50479bfc04ea4a68fe6a2a731f852ab7ef6024f2927f15e8b8d0c4a83">a8b0df52fc69ea18510492bd532eeda5abb824d8f1dad69a9a35d594ef5c4e745d9dfdeaa73551f6db9ec853f35496c3b91c04a488b6657b21c8dc72a32ec96d74c3597ef5dfa94d1eb595b647c63215ff89eeb3a20abc0553c7eb8805152bbb2f2bde7c9a9519c5b61bbd3a392744febe0a6719a07c940ace87153553bc5f85aeff9c5736548c35298c652fce6de06ae1efbcac91df71995a480647091a4b6df3bb7c5fe2b10a12bac197f2fa7747fdddcc983fe9e3f1148dbaf427b931ac22b404b93a6ec2d860a710c1fa6ff0ebff6ece32102871bca675292c450e51594548f65e2a4b37cd88b9688202715063027871973bd42dda1f69363105396e742d3dc3b8c434f626bbb4ab076feb2eb9422d432a27080ba1f72fa1d2d04bbe810b70a8b4242679ed0825ab0b24a3db043327ef52255cce1a4c76ee499487dc8bd3fa0312e02bbb951722581d5d379bb62f1fa3bc0cd7d50eef09fe833e0ea61f60f3f9d49631d4c49dc486a573ecb1cd845dae4d6fb1412651c42a2bc887dfc5057500076fad789542353677196552479aebef04c3ec8ca3e6822d441db510fd4067435518889d2de435d705b2823ae15c363972f1a8816ea3273a12ebd47b03b64b26fd763cc68fad583309369ad36bc67e5c487b37bcc61253e4012ec3587623f1c718e802c2eae1d72f2925b09fb0a5229e056ba99cb4670fbc2d174e8cd6e88d74c0649c4399293dffc010116548bb3d21393beec59471d8d8189bf558266f724fefe1593b164f37788b149767429090ca37f04b571a2896d40e465af7a127868913fa329510f548159bec16ef59ccea0ec1db92066f7a7a65a7290b51767776690ead2769cf30df906980a963327b1b675d410baf364f3cb55c63a2b41cd69e9977e0ff840a8fe7ffb143023814c911f92150bce851c102b24db61a9480290026fda259ce4991b882f20ec2ba05bad09f95cfb6a9b2df90e089e1ed1e41268d5b241524dce53c3ad182404f0f3f2d42c87ec78286627dc37bb4901630a1c25937963edcf4b2ef1b1e235d24ac24337798997626cf662a71aba9886a447ad4614b845e606b468b8df935e2c4b9e35bc5210e82dae1a55dc683ecab2545cb2e93fbd381f1f4965dcf9986f234ac1952b365f5fba28ab9e480c63e8756076642f77bf9533ed770b021cb727851a38b4bfcd485ee8f3d707b40cd82948b1fb6c872ca7ef65895a45a1fe5a59f4ab0f0593e821eaf0ab0ea56a20904e7133ebd808c208ba54fa3a31f3352e14a00adbb83530a559f1bae7524c364c624d08cf4e1d1dabc5e1656f96aabaf88605071eb3f7f24e41cc886f7f7a58762743075159466b4e7324bb27cf971729bf01ae415bfd9bae719102279a93c514780fd5c0ec5b9d1e982f905b938de38abec9a9946ff1acd56e779a9c3fffc1aed993f48cf6f4024ac58b236d9609015bd18f576d5ce4bf16480dce673b47db39dca7416db9be3a879c3849fe9edb01eb238a8f42a007c6508c280b10b95b70a62829035bf86e801908d9080caae8c8e2a10215bc7ae93dc4179b06547478c3621cf6792d930f12af1a9c0bc36ff47d744be2d5027442b17e2b11e5dafb2b2bfd0a622bb28eaa9570894d83b4c2c5155815bcc0e00ba3eb699ec0fb2f841799c581a3b04ba3d0f354202dc4c930b9dd4b3ab7787433e40fd04f038ef6382adac7ac070e18886131e3c8b1853cf808c2298dd923b79202ff20c9f392c115176774d7b181748e6ab3cdfe63ac23d0afe0db421136130d9d0259fac06c274ab77235960b247b9509bcceec96f520e614ab5c1a1c4f46e44e45c31074611f670ac613f3dc291cfdfc50a1317e1681f5f5fd00b431ec6a2e48fb05441873de872a27f3b03ae9ed6f42c381e8b8434bbf275cc6729761f20a5f5b6a903690b03fe24589d8b9023716ffb37a76e68645698a898a05dcd519969048fe9b041fa8e9df94990c4c8cba0cd2237bbb9ba12dc8ef4f929762a0ce6d9f004dce7c4e55f02d8337ecbe13ea28160ac910c64728931f33a3d5df6fa4ee14ad5d164d16c22f258a7704491ab7f2422b9e7d432212f57f37c7afa1a691215da09d16a0cb506ee7dbd09bdec3f71d58d29da485a09af9f84e4479fa0f332accbc0e0d154506dbd0e52c2007feb3374ee7e686c7bb9de69da7fbc8d04e883f561475deee87415f9f3e84508f03a454948f9466b774ccc8e4d59c14b903cfa561994aeb8891754ebd5bf8d43f50c537df49e639a393cc423235d6fe2429c6bb5680d150f743e68f3715a8dbab935c7ff97b51f1485a35bfb481265622b88c056f2431f5e7a5947411ffff4bfa4626729f2c83ae1d3206d219f7c3bf878c5a84faddfc5e3bdf1394b98980c5f9cfbc7f9f41cf671f1e07714e0dcc9d4f9fa03810e726d3e5cc10d381069517fd303e9f1c162755ddad5d4f307daca03fcc7744fffe338a8126469c3f03c82c3fc3a6c706359809c9021f8b166d0687d5bafbeb5af175be47862a89af705c24250c29a486fc5b038ba16a87c8c7ec2e88e07bb6753734db27ec5d4a179e83e2990c4e85e033b434c3e65da7ea8434f048607d57719ec795729d44771581b1dafef585827b54e030489fc5a8bc3aaa48c0cd814f14fce3eccc94f47f08fe6ba170800dbad2b3ebf3405fe3ada98880b59a7c82efe831f1b4e673e3238759ab3bfe272944cb7e3ebc083ced2ed6b49cddccb786f2dc180cdf0dcb7177e78bff66bd2e28110221051dbf5abd84d7413f7c17005ebd4bc88ccded4a35ea0d469f06316b9c8ef228e84aab94d94c0538be6e7ad3ea1e9626da975c7d5aae7fb5dfb88cd613e3bfbe32a0bc60e9cc1f634550ec044a906470099271a361c08569ded0dbdc29e591d1394a3e42a313d96f46d23936d333ee9943d439a69437c57f109cb763163abe50a12168f7dbd0a3c0978bcf87c88d8ca637e71fd7559f86e57f1c561afb4f86804f696c39b055d88567c38d4ae9505b07cf39823b100de1d70f2bb2a76958d70251d9dabe288b8cdd442ac2488b17d1a6c61be2a98492f65ab955ae296933db23a87c137d45e77c1358324d11c53bcf4290a47238bf9c9d76c51b394615d038cff99fc6e225b8d5f81e7aece480f46098eb05bac34a665784b0822c3e49c6c4789cf811d3933ec796906523a8d09f873a428d7e05e9b2db4fc226ad880d060081960a8bf289a52c3590cc1a8e7678b0bcd007f4ab394a40be626fe89e1c7016150ccc4f351f35f0a0c7b5aaf5715d709e50fa4af1f7f56ad4b4601b9a6adc29227572a545711c3704e5433b795877ba874596ab27198ca7d2efd8895d79534c3cf5bffddf3a6933c1d2356a2cbea0ccb81cf71137aa44dc3ac93aa1446fab06f83274d0838feceb646e3f9e50bf03fe451f323e88040851082c1befde0d45b3ac8ff977284af897c4ecf21437c453970610b72d87de689e21298fb136511e2df8a175c00b7bbef1c8582c71f264f6d295814d62044baf772241d111bfc161ecf8f8523b5b560110441a47446b409ad0241d07182de145b1190b8fe6b2a2dc12a38f90d1131372811552b4700d3c263bcde738375f940f4d5937dd2b6054710ae90a8501c01d653526b39062d2e967b45371f29e07b86d593d0260ccee7ff1fc1bb9b8770db029c70580a42a3f4ec0b4804dbe8f193993ed893883b6ed53a78692a0ca2dcc31602bd6dee9c826fab9859b1e118dd0f476ebbdcd3950557d70a82ab52e3541bb36c7363618ae631ddc1533540903224f904ede5c703f241301fd65a61fa8f7cc4e271e08952c68229fbe4237c0d951f66c9d6a5277f85c88c8035b273838d4424e4913fc64ad0cb46b3a3d11ef1846f6c1d71c62100f9a84aaf9ecdd3771b3066e1f492ebaf2a091c3b39eae12b1092099da5ad10be7740cdeb77ef1eb6265bea755659745e3a3b1e3dfb9fd6e51e51c2300cb7ccb13ce1f829c2d6d45fc5fb8b857a8b850e5972b238761e6d03dac6472266ba163f3c58ded59a499e7d9356dd5f2c02c4ae2f0ed415827db0455c3f06d283cb4032800357825e2c6d758d621dfb225a45901803ff8f0118897a46f98afbe0b887ffae834a0702d2d673f41fdbbff6e4f0aef0925cb15ad45882afd181d7f67a420b388f87caf9141ca4726f7dd091ba1629cae8847f80ba871644a1afad6a474f44fa2e7aea22f9a8c83bf7fa6f18f1fc0b9b3b1c674e01ac056e3b778c8ef567661a42138f8ed89b49d9c2b4efe9ebae6125c5d651faf07285753a7b8ef80c5a15b5994dab93fa58c4daac0934afe6f932d857c3f7e244c1da818cf8f2431768ab910b9b717f66ab9e69baed83848f9d4edaf83874202c27999444877ab75ff98950ae10b89992acb9ee7c88a2a615086cc4f924cb695992d92e8762e55f53522203058f745ad9a50fdb9b2efe538babc5892bb43756960f4db165c92c9a0964be92c1ef2d3c24165526c147fb5736e79dbdd714001ee7d8f3cb43a11a07a0aa128ac895eb150b2182f86f81282c170099a104c47935f06978bc40d8cb575e0098e9280c411f47faded7a5b15b8b1248496e28b04d3847b32b60556047b3ec041b5e14b752f4ffcbb6798061cca6b95b56dc0204b8b52a30ca4cb810f398fbacbd3eb2ed078052e3b1f0edac043412d90ef27a8c1d3db180454453fb9beb428ac050e1cf066d16bde7f439506523085e5578a07a5e7f113e18d11ed62f07b99cbb45b8492351c5a03801a9bd9a4f8c396bbd1b168448f7f16383cc2653d147c1e5883db31855257798bb9d42e7da065281766de0e35b249fa63a66987e7b194d7fa937253414e68b5136f48e0341f23facf6f7f68b298e825265f03f0035b3150530d676bb0236a461e77c99a8dfd3b733adf271a448d7e976b9dba021c14044cfbf492c0c338b5a9e1940b9acb3ce249412874664e6d023454eb5581602bbd2c1ef738442b52d37e5171cc7d01e1e7042ecab46591f47160990b97d8d8505c88017c07b12de03aa4756a02f719ee7d7f4b045b015c6eb50da85b458f1204e04eed8deaa7769d469b0828faf606ff6bcc2482512f5ac6606905e24708b5784a13c2a3959940274062d18920f9c2d2c92bad26abb350501eb704d912e2f19974130ac8e3dab1115c31710345fcfe6b593f4d7a03011cd79a4cf61a35e090f7769b8ce29aed6c4ff868ee70b52481e5a9ccd8d57fc5d92b973fedcc9bee099079c7b77e19198b2d40e2271c56fc97bd2577e9c1fc87e7b9f66feb13e412af08045b6f8fed2745140214fe6eade14bbb8614607d160f5f46c80e5419e3c7ee3a684e42943ca6f1b15f032d917e34cabdd53f7c97fab5429ae7dfda07874ed24519c4a58f6ba417f0b4048245c4fdacfab54465611c27c37f82e7487d69c09840bb7641802efa257f0bebc3d7dff5b12c4bda6000ba5418c2fcf2620d1b9dd89208a693d40f8156a645d490af482777258a8ed2ba00761b08d6f0ee05c6066fa13761b6f8881fcc89fad3b8da489a4b15285ead5d46a08e7d8f0dc5cebed523d0a51339362b1c68cc611b742275e5bf51575c1253e6ee74119c253d7f57d90eca3e25561ee922438ab635db72de1644da670f6a35e0189e56b6bdabaf32f8faa22b73c33352c60710b02f50e679bb9f18af391c78526f9ff0e5e06eafcf53e3297caaa32e69dc60cd09d2db1282ea4c17b5b1d832f8af1f673ea51fba608cbc6b5f8ef9f710d39d1e849acbc2e4e28cba4b38503931c669a69c504c9807bbd48881c110c08c5aad1f55ad2c5cf78d263320a7d9f7bcb3e015be26ec1c27b510a9c5c6b197ec465f0ba97dcb204638cf02a49fb12e9a536605053a57a5f01693cb13caaeb4ea561d963043248b82bc193f599d7d821c01f7a5d2c3f69aac71ba27d0d3befa0dc3940e9aa33b93688bbb8c87b883a5a355418b1352e1d824f96e8365d7f9eccc29a541b8627b222dac13a955e162df5dcfdeea8e17f755ce70b1e81e4aa82425ccd1a3f34d4a7385fad13ab8cd8dd648138f10fdbed7d8e5587d40863c39e9a453e7d93cf824d051f704dee7850b5a9b5bf83097ddaf51129d7020275e10516fb377afd6ada09a469d050bf042e8b884a1251128526e40630601b0f55300bb7b035a35fe10da806778dbd376d9080e9d195276a6888b9381d31a24230175c1c0fac3fd9f05436f34430abfdf56b44065779e730325f5c56454f50289df6637e41014a5df37ca0a967c792223da0a3f919b9f2abe8f2755ae8cad6015944ba473b60d53371488d3924708b8905f4dabada85ba565dcb5c9fbff41959951a69c074b1cad857d1d1b00844dbc9c5bc68c722e37648a9cacba9ff34c52737c394a41d27159d4f7619e9b02155bb057a046c228a38f608b15a46b0b71feea39ed902c480912b80417a18d8c0893f60e664a6ee9a63af69d37fe0b094d556fbf7696bd1f4ff7f1f38d71f2344e2adfafa0110e127805d5c711dfeff2e731d9f13421a706c906028310ad0c3e6724854ab3259e218fa512edc0193e05c58012b5b33a10bee0bfab9103a169358a97c6b84d994f809185cbd139f16f9c174306d5e6b792272929e28e347df32cc4d88e4d17b4a963c6c3266f475b0fd58d53059a4a2041440427a1f3fbe810450ecaa6e130aa9c562</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">Hey, password is required here.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">主要是整理一下怎么介绍我的一些项目</summary>
    
    
    
    <category term="面试" scheme="https://www.karlyn.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="项目介绍" scheme="https://www.karlyn.xyz/tags/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    
    <category term="Java" scheme="https://www.karlyn.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>K个一组翻转链表</title>
    <link href="https://www.karlyn.xyz/posts/reverse-nodes-in-k-group.html"/>
    <id>https://www.karlyn.xyz/posts/reverse-nodes-in-k-group.html</id>
    <published>2025-03-18T08:42:03.000Z</published>
    <updated>2025-03-18T08:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1>K个一组翻转链表</h1><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&amp;envId=top-100-liked">LeetCode原题链接</a></p><h2 id="题目描述">题目描述</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="示例1"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="示例2"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p>**进阶：**你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h2 id="题目分析">题目分析</h2><p>这题难度被划归为困难，其实显然是不能达到困难题的难度的，只不过如果不习惯封装编程，单独将反转链表的方法单独写的话可能会有一些边界类型的问题出现。不过提到了需要使用 <code>O(1)</code> 额外内存空间，前置题目为反转链表，题目链接为：<a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">反转链表</a>，只不过反转链表提到可以使用递归或者迭代的方式，但是递归的方式显然需要使用系统栈，无法实现额外内存空间需求，所以这题几乎已经锁定使用迭代的方式进行反转。</p><p>首先我们先尝试做一下反转链表这道题目</p><h3 id="反转链表">反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="示例1"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><p>官方定义的链表结构还是比较简单的，没有要用户自己定义链表，有些企业的面试题是需要自己定义的嘛，所以我们也简单自己定义一下，防患未然了属于是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*定义链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line"><span class="comment">//空参构造方法</span></span><br><span class="line">ListNode()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ListNode(<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="built_in">this</span>.val=val;</span><br><span class="line">&#125;</span><br><span class="line">ListNode(<span class="type">int</span> val,ListNode next)&#123;</span><br><span class="line"><span class="built_in">this</span>.val=val;</span><br><span class="line"><span class="built_in">this</span>.next=next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现任务之前，先简单实现一个输入获取和结果打印的方法，便于本地自行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">readDate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    String[] vals = sc.nextLine().replaceAll(<span class="string">&quot;^\\[*|\\]*$&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span>(String val:vals)&#123;</span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(Integer.valueOf(val));</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printListNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> != head)&#123;</span><br><span class="line">        sb.append(head.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是正常实现了，我们分为两种方式实现吧，首先是比较简单的递归的方式实现，递归的方式就是不断把后半段反转然后作为前半段的头部分。</p><p>我的代码可能有一点唐氏，讲得也没有官方的好，所以我贴在这里，简单介绍一下，一些注释基本代表了我的想法，需要注意的只有一点，就是需要先翻转后面的节点，然后再和前面的节点拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表的递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 后面需要反转的链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pre 已经完成反转的前半部分的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转完之后链表的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseListDFS</span><span class="params">(ListNode head,ListNode pre)</span>&#123;</span><br><span class="line">  <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//定义递归终点，也就是最后一个节点，直接把它和它前面的那个节点拼起来然后返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head.next)&#123;</span><br><span class="line">      head.next=pre;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果不是递归终点，这部分就需要理解一下</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//首先是将后面部分翻转！</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> reverseListDFS(head.next, head);</span><br><span class="line">      <span class="comment">//然后将改节点的next改为pre，拼接起来，顺序一定不能错</span></span><br><span class="line">        head.next = pre;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reverseListDFS(head,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让我们来实现一下迭代的方式，迭代主要还是双指针的思路，其实相对而言思路比递归更容易理解一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表迭代实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转完之后链表的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseListIter</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//定义双指针，这个定义是有技巧的，因为头节点的next要是null</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//依次设置前指针的next为后指针</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> != pre)&#123;</span><br><span class="line">        ListNode tmp=pre.next;</span><br><span class="line">        pre.next = lst;</span><br><span class="line">        lst = pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前指针为空时，后指针所指着的位置就是最后一个Node，也就是我们所需要的head</span></span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后反转链表部分我们就基本讲完了，但是迭代这个部分的代码在后面我们还需要进行一点小小的修改，为什么呢，因为K个一组反转链表，链表的终点不是null，而是我们需要的终点是第K个节点。</p><p>接下来就是K个一组反转链表的任务，简单来说，我们只需要把任务拆成K个反转链表的子任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseSubList</span><span class="params">(ListNode head, ListNode last)</span> &#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//定义双指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//依次设置前指针的next为后指针</span></span><br><span class="line">    <span class="keyword">while</span>(last != lst)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        pre.next = lst;</span><br><span class="line">        lst = pre;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//当k=1的时候，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == k) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//为了统一以及便于找到头，我们定义一个伪头部，其实这是很常用的方法</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fake_head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    fake_head.next=head;</span><br><span class="line">    <span class="comment">//如果k不等于1，接下来我们就需要定义一个节点，这个节点所需要做的事情就是找到每组的第K个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">findK</span> <span class="operator">=</span> fake_head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lst_one</span> <span class="operator">=</span> fake_head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里只需要判断findK是不是空，因为它一直走在其余两个交换位置的指针的前面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span>!=findK)&#123;</span><br><span class="line">        <span class="comment">//如果不是第K个，直接后移，不做处理</span></span><br><span class="line">        <span class="keyword">if</span>(count!=k)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            findK=findK.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是第K个</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//重置寻找循环</span></span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//首先是获得子段的头，子段的尾就是findK</span></span><br><span class="line">            ListNode child_head=lst_one.next;</span><br><span class="line">            ListNode K_next=findK.next;</span><br><span class="line">            <span class="comment">//然后进行子段反转，这里会把它的头尾都断开，所以之后就需要重新拼接</span></span><br><span class="line">            reverseSubList(child_head,findK);</span><br><span class="line">            <span class="comment">//然后将前面的子段和尾节点拼接</span></span><br><span class="line">            lst_one.next=findK;</span><br><span class="line">            <span class="comment">//将头节点和后面的节点拼接</span></span><br><span class="line">            child_head.next=K_next;</span><br><span class="line">            <span class="comment">//重置last_one和findK</span></span><br><span class="line">            lst_one = child_head;</span><br><span class="line">            findK = child_head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fake_head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只能说，很优雅，但是还是建议大家看看官解，我写的很简陋。</p>]]></content>
    
    
    <summary type="html">看懂这篇，反转链表系列就都能看懂啦！</summary>
    
    
    
    <category term="链表" scheme="https://www.karlyn.xyz/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="Hot100" scheme="https://www.karlyn.xyz/tags/Hot100/"/>
    
  </entry>
  
</feed>
